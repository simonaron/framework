// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R3A
// for  (pi@pi-02) on Sun Apr 22 07:11:59 2018

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "SEQUENCE_EXECUTOR.hh"

namespace SEQUENCE__EXECUTOR {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();
static boolean init_comp_type(const char *component_type, boolean init_base_comps);
static boolean start_ptc_function(const char *function_name, Text_Buf& function_arguments);

/* Literal string constants */

static const CHARSTRING cs_1(9, "INTERFACE"),
cs_2(7, "PARAM_1"),
cs_4(33, "SEQUENCE_EXECUTOR: Delay timeout!"),
cs_0(32, "SEQUENCE_EXECUTOR: Step started!"),
cs_3(46, "SEQUENCE_EXECUTOR: Step successfully finished!"),
cs_5(32, "SEQUENCE_EXECUTOR: Step timeout!");
static const unsigned char module_checksum[] = { 0x2a, 0xca, 0x10, 0x83, 0x46, 0xa2, 0x82, 0xe8, 0x69, 0xf6, 0x2f, 0x38, 0xb3, 0x18, 0x2d, 0xb5 };

/* Global variable definitions */

const TTCN_Typedescriptor_t& CT__SEQUENCE__EXECUTOR__SequenceExecutor_descr_ = COMPONENT_descr_;
TASK__BUILDER::PT__TASK__BUILDER__TaskBuilderPort CT__SEQUENCE__EXECUTOR__SequenceExecutor_component_p__taskBuilder("p_taskBuilder");
TASK::PT__TASK__TaskExecutorPort CT__SEQUENCE__EXECUTOR__SequenceExecutor_component_p__task("p_task");
TTCN_Module module_object("SEQUENCE_EXECUTOR", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, init_comp_type, start_ptc_function, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_3,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Bodies of functions, altsteps and testcases */

void f__SEQUENCE__EXECUTOR__SequenceExecutor(const COMPONENT& taskBuilder, const LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__ActionSequence& sequence)
{
TTCN_Location current_location("SEQUENCE_EXECUTOR.ttcn", 16, TTCN_Location::LOCATION_FUNCTION, "f_SEQUENCE_EXECUTOR_SequenceExecutor");
current_location.update_lineno(20);
/* SEQUENCE_EXECUTOR.ttcn, line 20 */
TTCN_Runtime::connect_port(self, CT__SEQUENCE__EXECUTOR__SequenceExecutor_component_p__taskBuilder.get_name(), taskBuilder, TASK__BUILDER::CT__TASK__BUILDER__TaskBuilder_component_p__taskBuilderPort.get_name());
{
current_location.update_lineno(22);
/* SEQUENCE_EXECUTOR.ttcn, line 22 */
INTEGER i(0);
current_location.update_lineno(22);
/* SEQUENCE_EXECUTOR.ttcn, line 22 */
for ( ; ; ) {
current_location.update_lineno(22);
/* SEQUENCE_EXECUTOR.ttcn, line 22 */
if (!(i < sequence.size_of())) break;
current_location.update_lineno(23);
/* SEQUENCE_EXECUTOR.ttcn, line 23 */
TEST__API__Functions::f__TEST__API__Subject__setverdict(PASS, cs_0);
current_location.update_lineno(25);
/* SEQUENCE_EXECUTOR.ttcn, line 25 */
FLOAT v__delay(0.0);
current_location.update_lineno(26);
/* SEQUENCE_EXECUTOR.ttcn, line 26 */
FLOAT v__timeout(5.0);
current_location.update_lineno(27);
/* SEQUENCE_EXECUTOR.ttcn, line 27 */
TASK__BUILDER::RT__TASK__BUILDER__TaskBuilderMission mission;
current_location.update_lineno(30);
/* SEQUENCE_EXECUTOR.ttcn, line 30 */
{
boolean tmp_3;
{
boolean tmp_0 = sequence.is_bound();
if(tmp_0) {
const int tmp_1 = i;
tmp_0 = (tmp_1 >= 0) && (sequence.size_of() > tmp_1);
if(tmp_0) {
const LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__Action& tmp_2 = sequence[tmp_1];
tmp_0 = tmp_2.is_bound();
if(tmp_0) {
tmp_0 = tmp_2.ischosen(LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__Action::ALT_InterfaceAction);
}
}
}
tmp_3 = tmp_0;
}
if (tmp_3) {
current_location.update_lineno(31);
/* SEQUENCE_EXECUTOR.ttcn, line 31 */
{
boolean tmp_11;
{
boolean tmp_4 = sequence.is_bound();
if(tmp_4) {
const int tmp_5 = i;
tmp_4 = (tmp_5 >= 0) && (sequence.size_of() > tmp_5);
if(tmp_4) {
const LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__Action& tmp_6 = sequence[tmp_5];
tmp_4 = tmp_6.is_bound();
if(tmp_4) {
tmp_4 = tmp_6.ischosen(LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__Action::ALT_InterfaceAction);
}
if(tmp_4) {
const LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__Action& tmp_7 = tmp_6;
const LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__InterfaceAction& tmp_8 = tmp_7.InterfaceAction();
tmp_4 = tmp_8.is_bound();
if(tmp_4) {
const OPTIONAL<FLOAT>& tmp_9 = tmp_8.Delay();
switch (tmp_9.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_4 = FALSE;
break;
case OPTIONAL_OMIT:
tmp_4 = FALSE;
break;
default:
{
const FLOAT& tmp_10 = (const FLOAT&) tmp_9;
tmp_4 = tmp_10.is_present();
break;}
}
}
}
}
}
tmp_11 = tmp_4;
}
if (tmp_11) {
current_location.update_lineno(32);
/* SEQUENCE_EXECUTOR.ttcn, line 32 */
v__delay = const_cast< const LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__ActionSequence&>(sequence)[i].InterfaceAction().Delay();
}
}
current_location.update_lineno(34);
/* SEQUENCE_EXECUTOR.ttcn, line 34 */
{
boolean tmp_20;
{
boolean tmp_13 = sequence.is_bound();
if(tmp_13) {
const int tmp_14 = i;
tmp_13 = (tmp_14 >= 0) && (sequence.size_of() > tmp_14);
if(tmp_13) {
const LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__Action& tmp_15 = sequence[tmp_14];
tmp_13 = tmp_15.is_bound();
if(tmp_13) {
tmp_13 = tmp_15.ischosen(LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__Action::ALT_InterfaceAction);
}
if(tmp_13) {
const LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__Action& tmp_16 = tmp_15;
const LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__InterfaceAction& tmp_17 = tmp_16.InterfaceAction();
tmp_13 = tmp_17.is_bound();
if(tmp_13) {
const OPTIONAL<FLOAT>& tmp_18 = tmp_17.Timeout();
switch (tmp_18.get_selection()) {
case OPTIONAL_UNBOUND:
tmp_13 = FALSE;
break;
case OPTIONAL_OMIT:
tmp_13 = FALSE;
break;
default:
{
const FLOAT& tmp_19 = (const FLOAT&) tmp_18;
tmp_13 = tmp_19.is_present();
break;}
}
}
}
}
}
tmp_20 = tmp_13;
}
if (tmp_20) {
current_location.update_lineno(35);
/* SEQUENCE_EXECUTOR.ttcn, line 35 */
v__timeout = const_cast< const LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__ActionSequence&>(sequence)[i].InterfaceAction().Timeout();
}
}
current_location.update_lineno(38);
/* SEQUENCE_EXECUTOR.ttcn, line 38 */
TTCN_Runtime::begin_action();
TTCN_Logger::log_event_str("+ ---------------------------------------------------------------------------------------------");
TTCN_Runtime::end_action();
current_location.update_lineno(39);
/* SEQUENCE_EXECUTOR.ttcn, line 39 */
TTCN_Runtime::begin_action();
TTCN_Logger::log_event_str("  Execute ");
const_cast< const LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__ActionSequence&>(sequence)[i].InterfaceAction().Command().log();
TTCN_Logger::log_event_str(" on ");
const_cast< const LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__ActionSequence&>(sequence)[i].InterfaceAction().InterfaceName().log();
TTCN_Runtime::end_action();
current_location.update_lineno(40);
/* SEQUENCE_EXECUTOR.ttcn, line 40 */
TTCN_Runtime::begin_action();
TTCN_Logger::log_event_str("  Params: ");
const_cast< const LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__ActionSequence&>(sequence)[i].InterfaceAction().Parameters().log();
TTCN_Runtime::end_action();
current_location.update_lineno(41);
/* SEQUENCE_EXECUTOR.ttcn, line 41 */
TTCN_Runtime::begin_action();
TTCN_Logger::log_event_str("  Delay: ");
v__delay.log();
TTCN_Logger::log_event_str(" Timeout: ");
v__timeout.log();
TTCN_Runtime::end_action();
current_location.update_lineno(42);
/* SEQUENCE_EXECUTOR.ttcn, line 42 */
TTCN_Runtime::begin_action();
TTCN_Logger::log_event_str("= - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
TTCN_Runtime::end_action();
current_location.update_lineno(43);
/* SEQUENCE_EXECUTOR.ttcn, line 43 */
mission.TaskName() = const_cast< const LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__ActionSequence&>(sequence)[i].InterfaceAction().Command();
{
TASK__BUILDER::RT__TASK__BUILDER__TaskBuilderParameters& tmp_23 = mission.Parameters();
tmp_23.set_size(2);
{
TASK__BUILDER::RT__TASK__BUILDER__TaskBuilderParameter& tmp_24 = tmp_23[0];
tmp_24.Name() = cs_1;
tmp_24.Value() = const_cast< const LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__ActionSequence&>(sequence)[i].InterfaceAction().InterfaceName();
}
{
TASK__BUILDER::RT__TASK__BUILDER__TaskBuilderParameter& tmp_25 = tmp_23[1];
tmp_25.Name() = cs_2;
tmp_25.Value() = const_cast< const LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__ActionSequence&>(sequence)[i].InterfaceAction().Parameters()[0];
}
}
mission.CreatedTask() = OMIT_VALUE;
}
else {
}
}
current_location.update_lineno(56);
/* SEQUENCE_EXECUTOR.ttcn, line 56 */
TIMER t__delay("t_delay");
current_location.update_lineno(56);
/* SEQUENCE_EXECUTOR.ttcn, line 56 */
TIMER t__timeout("t_timeout");
current_location.update_lineno(57);
/* SEQUENCE_EXECUTOR.ttcn, line 57 */
t__delay.start(v__delay);
current_location.update_lineno(58);
/* SEQUENCE_EXECUTOR.ttcn, line 58 */
t__timeout.start(v__timeout);
current_location.update_lineno(61);
/* SEQUENCE_EXECUTOR.ttcn, line 61 */
CT__SEQUENCE__EXECUTOR__SequenceExecutor_component_p__taskBuilder.send(mission);
current_location.update_lineno(62);
/* SEQUENCE_EXECUTOR.ttcn, line 62 */
{
tmp_26:
TASK__BUILDER::RT__TASK__BUILDER__TaskBuilderMission_template tmp_27;
tmp_27.TaskName() = const_cast< const TASK__BUILDER::RT__TASK__BUILDER__TaskBuilderMission&>(mission).TaskName();
tmp_27.Parameters() = ANY_VALUE;
tmp_27.CreatedTask() = ANY_VALUE;
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = CT__SEQUENCE__EXECUTOR__SequenceExecutor_component_p__taskBuilder.receive(tmp_27, &(mission), any_compref, NULL, NULL);
if (alt_flag == ALT_YES) break;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_26;
}
current_location.update_lineno(62);
/* SEQUENCE_EXECUTOR.ttcn, line 62 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone receive statement failed in file SEQUENCE_EXECUTOR.ttcn, line 62.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(63);
/* SEQUENCE_EXECUTOR.ttcn, line 63 */
TTCN_Runtime::connect_port(self, CT__SEQUENCE__EXECUTOR__SequenceExecutor_component_p__task.get_name(), const_cast< const TASK__BUILDER::RT__TASK__BUILDER__TaskBuilderMission&>(mission).CreatedTask(), TASK::CT__TASK__Task_component_p__taskPort.get_name());
current_location.update_lineno(66);
/* SEQUENCE_EXECUTOR.ttcn, line 66 */
CT__SEQUENCE__EXECUTOR__SequenceExecutor_component_p__task.send(TASK::ET__TASK__ControlIncomingMessage(TASK::ET__TASK__ControlIncomingMessage::EV__TASK__INIT));
current_location.update_lineno(67);
/* SEQUENCE_EXECUTOR.ttcn, line 67 */
{
tmp_28:
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = CT__SEQUENCE__EXECUTOR__SequenceExecutor_component_p__task.receive(TASK::ET__TASK__ControlOutcomingMessage_template(TASK::ET__TASK__ControlOutcomingMessage::EV__TASK__INITIALISED), NULL, any_compref, NULL, NULL);
if (alt_flag == ALT_YES) break;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_28;
}
current_location.update_lineno(67);
/* SEQUENCE_EXECUTOR.ttcn, line 67 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone receive statement failed in file SEQUENCE_EXECUTOR.ttcn, line 67.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(69);
/* SEQUENCE_EXECUTOR.ttcn, line 69 */
{
tmp_29:
alt_status tmp_29_alt_flag_0 = ALT_MAYBE;
alt_status tmp_29_alt_flag_1 = ALT_MAYBE;
alt_status tmp_29_alt_flag_2 = ALT_MAYBE;
alt_status tmp_29_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_29_alt_flag_0 == ALT_MAYBE) {
current_location.update_lineno(70);
/* SEQUENCE_EXECUTOR.ttcn, line 70 */
tmp_29_alt_flag_0 = CT__SEQUENCE__EXECUTOR__SequenceExecutor_component_p__task.receive(TASK::ET__TASK__ControlOutcomingMessage_template(TASK::ET__TASK__ControlOutcomingMessage::EV__TASK__FINISH), NULL, any_compref, NULL, NULL);
if (tmp_29_alt_flag_0 == ALT_YES) {
current_location.update_lineno(71);
/* SEQUENCE_EXECUTOR.ttcn, line 71 */
TTCN_Runtime::begin_action();
TTCN_Logger::log_event_str("  Verdict: PASS");
TTCN_Runtime::end_action();
current_location.update_lineno(72);
/* SEQUENCE_EXECUTOR.ttcn, line 72 */
TEST__API__Functions::f__TEST__API__Subject__setverdict(PASS, cs_3);
break;
}
}
if (tmp_29_alt_flag_1 == ALT_MAYBE) {
current_location.update_lineno(74);
/* SEQUENCE_EXECUTOR.ttcn, line 74 */
tmp_29_alt_flag_1 = t__delay.timeout(NULL);
if (tmp_29_alt_flag_1 == ALT_YES) {
current_location.update_lineno(75);
/* SEQUENCE_EXECUTOR.ttcn, line 75 */
TEST__API__Functions::f__TEST__API__Subject__setverdict(PASS, cs_4);
current_location.update_lineno(76);
/* SEQUENCE_EXECUTOR.ttcn, line 76 */
CT__SEQUENCE__EXECUTOR__SequenceExecutor_component_p__task.send(TASK::ET__TASK__ControlIncomingMessage(TASK::ET__TASK__ControlIncomingMessage::EV__TASK__START));
current_location.update_lineno(77);
/* SEQUENCE_EXECUTOR.ttcn, line 77 */
goto tmp_29;
}
}
if (tmp_29_alt_flag_2 == ALT_MAYBE) {
current_location.update_lineno(79);
/* SEQUENCE_EXECUTOR.ttcn, line 79 */
tmp_29_alt_flag_2 = t__timeout.timeout(NULL);
if (tmp_29_alt_flag_2 == ALT_YES) {
current_location.update_lineno(80);
/* SEQUENCE_EXECUTOR.ttcn, line 80 */
TTCN_Runtime::begin_action();
TTCN_Logger::log_event_str("  Verdict: FAIL - Action timeout occured!");
TTCN_Runtime::end_action();
current_location.update_lineno(81);
/* SEQUENCE_EXECUTOR.ttcn, line 81 */
TEST__API__Functions::f__TEST__API__Subject__setverdict(FAIL, cs_5);
break;
}
}
if (tmp_29_default_flag == ALT_MAYBE) {
tmp_29_default_flag = TTCN_Default::try_altsteps();
if (tmp_29_default_flag == ALT_YES || tmp_29_default_flag == ALT_BREAK) break;
else if (tmp_29_default_flag == ALT_REPEAT) goto tmp_29;
}
current_location.update_lineno(69);
/* SEQUENCE_EXECUTOR.ttcn, line 69 */
if (tmp_29_alt_flag_0 == ALT_NO && tmp_29_alt_flag_1 == ALT_NO && tmp_29_alt_flag_2 == ALT_NO && tmp_29_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file SEQUENCE_EXECUTOR.ttcn between lines 69 and 83.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(84);
/* SEQUENCE_EXECUTOR.ttcn, line 84 */
TTCN_Runtime::disconnect_port(self, CT__SEQUENCE__EXECUTOR__SequenceExecutor_component_p__task.get_name(), const_cast< const TASK__BUILDER::RT__TASK__BUILDER__TaskBuilderMission&>(mission).CreatedTask(), TASK::CT__TASK__Task_component_p__taskPort.get_name());
current_location.update_lineno(85);
/* SEQUENCE_EXECUTOR.ttcn, line 85 */
TTCN_Runtime::begin_action();
TTCN_Logger::log_event_str("+ ---------------------------------------------------------------------------------------------");
TTCN_Runtime::end_action();
current_location.update_lineno(86);
/* SEQUENCE_EXECUTOR.ttcn, line 86 */
TTCN_Runtime::begin_action();
TTCN_Logger::log_char('\0');
TTCN_Runtime::end_action();
current_location.update_lineno(22);
/* SEQUENCE_EXECUTOR.ttcn, line 22 */
{
INTEGER tmp_30;
++i;
}
}
}
}

void start_f__SEQUENCE__EXECUTOR__SequenceExecutor(const COMPONENT& component_reference, const COMPONENT& taskBuilder, const LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__ActionSequence& sequence)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_SEQUENCE_EXECUTOR_SequenceExecutor(");
taskBuilder.log();
TTCN_Logger::log_event_str(", ");
sequence.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "SEQUENCE_EXECUTOR", "f_SEQUENCE_EXECUTOR_SequenceExecutor", text_buf);
taskBuilder.encode_text(text_buf);
sequence.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("SEQUENCE_EXECUTOR.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "SEQUENCE_EXECUTOR");
TASK__BUILDER::module_object.pre_init_module();
LANGUAGE::module_object.pre_init_module();
LANGUAGE::module_object.pre_init_module();
module_object.add_function("f_SEQUENCE_EXECUTOR_SequenceExecutor", (genericfunc_t)&f__SEQUENCE__EXECUTOR__SequenceExecutor, (genericfunc_t)&start_f__SEQUENCE__EXECUTOR__SequenceExecutor);
}

static void post_init_module()
{
TTCN_Location current_location("SEQUENCE_EXECUTOR.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "SEQUENCE_EXECUTOR");
TASK__BUILDER::module_object.post_init_module();
LANGUAGE::module_object.post_init_module();
LANGUAGE::module_object.post_init_module();
}

static boolean init_comp_type(const char *component_type, boolean init_base_comps)
{
(void)init_base_comps;
if (!strcmp(component_type, "CT_SEQUENCE_EXECUTOR_SequenceExecutor")) {
if (init_base_comps) {
Module_List::initialize_component("TEST_Definitions", "CT_TEST_Subject", FALSE);
}
CT__SEQUENCE__EXECUTOR__SequenceExecutor_component_p__taskBuilder.activate_port();
CT__SEQUENCE__EXECUTOR__SequenceExecutor_component_p__task.activate_port();
return TRUE;
} else return FALSE;
}

static boolean start_ptc_function(const char *function_name, Text_Buf& function_arguments)
{
if (!strcmp(function_name, "f_SEQUENCE_EXECUTOR_SequenceExecutor")) {
COMPONENT taskBuilder;
LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__ActionSequence sequence;
taskBuilder.decode_text(function_arguments);
sequence.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_SEQUENCE_EXECUTOR_SequenceExecutor(");
taskBuilder.log();
TTCN_Logger::log_event_str(", ");
sequence.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__SEQUENCE__EXECUTOR__SequenceExecutor(taskBuilder, sequence);
TTCN_Runtime::function_finished("f_SEQUENCE_EXECUTOR_SequenceExecutor");
return TRUE;
} else return FALSE;
}


} /* end of namespace */
