// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R3A
// for  (pi@pi-02) on Sun Apr 22 14:43:40 2018

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "GPIO_Functions.hh"

namespace GPIO__Functions {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();
static boolean start_ptc_function(const char *function_name, Text_Buf& function_arguments);

/* Literal string constants */

static const CHARSTRING cs_1(35, "GPIO TEST: Expected value received!"),
cs_2(37, "GPIO TEST: Unexpected value received!"),
cs_0(15, "Value received!");
static const unsigned char module_checksum[] = { 0xe2, 0x82, 0x01, 0xb6, 0x5b, 0x60, 0x3a, 0x8c, 0x62, 0x7a, 0x64, 0x33, 0x34, 0x0f, 0x49, 0xc9 };

/* Global variable definitions */

TTCN_Module module_object("GPIO_Functions", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, NULL, start_ptc_function, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_3,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Bodies of functions, altsteps and testcases */

void f__GPIO__Device__sendValue(const GPIOPinPort::GPIO__PIN__VALUE& newValue)
{
TTCN_Location current_location("GPIO_Functions.ttcn", 7, TTCN_Location::LOCATION_FUNCTION, "f_GPIO_Device_sendValue");
current_location.update_lineno(9);
/* GPIO_Functions.ttcn, line 9 */
GPIO__Definitions::CT__GPIO__Device_component_controller.send(newValue);
}

void start_f__GPIO__Device__sendValue(const COMPONENT& component_reference, const GPIOPinPort::GPIO__PIN__VALUE& newValue)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_GPIO_Device_sendValue(");
newValue.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "GPIO_Functions", "f_GPIO_Device_sendValue", text_buf);
newValue.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

GPIOPinPort::GPIO__PIN__VALUE f__GPIO__Device__receiveValue()
{
TTCN_Location current_location("GPIO_Functions.ttcn", 12, TTCN_Location::LOCATION_FUNCTION, "f_GPIO_Device_receiveValue");
current_location.update_lineno(15);
/* GPIO_Functions.ttcn, line 15 */
GPIOPinPort::GPIO__PIN__VALUE receivedValue;
current_location.update_lineno(16);
/* GPIO_Functions.ttcn, line 16 */
{
tmp_0:
alt_status tmp_0_alt_flag_0 = ALT_MAYBE;
alt_status tmp_0_alt_flag_1 = ALT_MAYBE;
alt_status tmp_0_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_0_alt_flag_0 == ALT_MAYBE) {
current_location.update_lineno(17);
/* GPIO_Functions.ttcn, line 17 */
tmp_0_alt_flag_0 = GPIO__Definitions::CT__GPIO__Device_component_controller.receive(GPIOPinPort::GPIO__PIN__DIRECTION_template(ANY_VALUE), NULL, any_compref, NULL, NULL);
if (tmp_0_alt_flag_0 == ALT_YES) {
current_location.update_lineno(18);
/* GPIO_Functions.ttcn, line 18 */
goto tmp_0;
}
}
if (tmp_0_alt_flag_1 == ALT_MAYBE) {
current_location.update_lineno(20);
/* GPIO_Functions.ttcn, line 20 */
tmp_0_alt_flag_1 = GPIO__Definitions::CT__GPIO__Device_component_controller.receive(GPIOPinPort::GPIO__PIN__VALUE_template(ANY_VALUE), &(receivedValue), any_compref, NULL, NULL);
if (tmp_0_alt_flag_1 == ALT_YES) {
current_location.update_lineno(21);
/* GPIO_Functions.ttcn, line 21 */
TEST__API__Functions::f__TEST__API__Subject__setverdict(PASS, cs_0);
current_location.update_lineno(22);
/* GPIO_Functions.ttcn, line 22 */
return receivedValue;
}
}
if (tmp_0_default_flag == ALT_MAYBE) {
tmp_0_default_flag = TTCN_Default::try_altsteps();
if (tmp_0_default_flag == ALT_YES || tmp_0_default_flag == ALT_BREAK) break;
else if (tmp_0_default_flag == ALT_REPEAT) goto tmp_0;
}
current_location.update_lineno(16);
/* GPIO_Functions.ttcn, line 16 */
if (tmp_0_alt_flag_0 == ALT_NO && tmp_0_alt_flag_1 == ALT_NO && tmp_0_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file GPIO_Functions.ttcn between lines 16 and 24.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(25);
/* GPIO_Functions.ttcn, line 25 */
return GPIOPinPort::GPIO__PIN__VALUE::LOW;
}

void start_f__GPIO__Device__receiveValue(const COMPONENT& component_reference)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_GPIO_Device_receiveValue(");
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "GPIO_Functions", "f_GPIO_Device_receiveValue", text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__GPIO__TestDevice__receiveExpectedValue(const GPIOPinPort::GPIO__PIN__VALUE& expectedValue)
{
TTCN_Location current_location("GPIO_Functions.ttcn", 30, TTCN_Location::LOCATION_FUNCTION, "f_GPIO_TestDevice_receiveExpectedValue");
current_location.update_lineno(32);
/* GPIO_Functions.ttcn, line 32 */
GPIOPinPort::GPIO__PIN__VALUE receivedValue(f__GPIO__Device__receiveValue());
current_location.update_lineno(33);
/* GPIO_Functions.ttcn, line 33 */
if ((receivedValue == expectedValue)) {
current_location.update_lineno(34);
/* GPIO_Functions.ttcn, line 34 */
TEST__API__Functions::f__TEST__API__Subject__setverdict(PASS, cs_1);
}
else {
current_location.update_lineno(36);
/* GPIO_Functions.ttcn, line 36 */
TEST__API__Functions::f__TEST__API__Subject__setverdict(FAIL, cs_2);
}
}

void start_f__GPIO__TestDevice__receiveExpectedValue(const COMPONENT& component_reference, const GPIOPinPort::GPIO__PIN__VALUE& expectedValue)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_GPIO_TestDevice_receiveExpectedValue(");
expectedValue.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "GPIO_Functions", "f_GPIO_TestDevice_receiveExpectedValue", text_buf);
expectedValue.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__GPIO__Controller__sendValue(const GPIOPinPort::GPIO__PIN__VALUE& newValue)
{
TTCN_Location current_location("GPIO_Functions.ttcn", 40, TTCN_Location::LOCATION_FUNCTION, "f_GPIO_Controller_sendValue");
current_location.update_lineno(42);
/* GPIO_Functions.ttcn, line 42 */
GPIO__Definitions::CT__GPIO__Controller_component_device.send(newValue);
}

void start_f__GPIO__Controller__sendValue(const COMPONENT& component_reference, const GPIOPinPort::GPIO__PIN__VALUE& newValue)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_GPIO_Controller_sendValue(");
newValue.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "GPIO_Functions", "f_GPIO_Controller_sendValue", text_buf);
newValue.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

GPIOPinPort::GPIO__PIN__VALUE f__GPIO__Controller__receiveValue()
{
TTCN_Location current_location("GPIO_Functions.ttcn", 45, TTCN_Location::LOCATION_FUNCTION, "f_GPIO_Controller_receiveValue");
current_location.update_lineno(48);
/* GPIO_Functions.ttcn, line 48 */
GPIOPinPort::GPIO__PIN__VALUE receivedValue;
current_location.update_lineno(49);
/* GPIO_Functions.ttcn, line 49 */
{
tmp_1:
alt_status tmp_1_alt_flag_0 = ALT_MAYBE;
alt_status tmp_1_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_1_alt_flag_0 == ALT_MAYBE) {
current_location.update_lineno(50);
/* GPIO_Functions.ttcn, line 50 */
tmp_1_alt_flag_0 = GPIO__Definitions::CT__GPIO__Controller_component_device.receive(GPIOPinPort::GPIO__PIN__VALUE_template(ANY_VALUE), &(receivedValue), any_compref, NULL, NULL);
if (tmp_1_alt_flag_0 == ALT_YES) {
current_location.update_lineno(51);
/* GPIO_Functions.ttcn, line 51 */
TEST__API__Functions::f__TEST__API__Subject__setverdict(PASS, cs_0);
current_location.update_lineno(52);
/* GPIO_Functions.ttcn, line 52 */
return receivedValue;
}
}
if (tmp_1_default_flag == ALT_MAYBE) {
tmp_1_default_flag = TTCN_Default::try_altsteps();
if (tmp_1_default_flag == ALT_YES || tmp_1_default_flag == ALT_BREAK) break;
else if (tmp_1_default_flag == ALT_REPEAT) goto tmp_1;
}
current_location.update_lineno(49);
/* GPIO_Functions.ttcn, line 49 */
if (tmp_1_alt_flag_0 == ALT_NO && tmp_1_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file GPIO_Functions.ttcn between lines 49 and 54.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(55);
/* GPIO_Functions.ttcn, line 55 */
return GPIOPinPort::GPIO__PIN__VALUE::LOW;
}

void start_f__GPIO__Controller__receiveValue(const COMPONENT& component_reference)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_GPIO_Controller_receiveValue(");
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "GPIO_Functions", "f_GPIO_Controller_receiveValue", text_buf);
TTCN_Runtime::send_start_component(text_buf);
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("GPIO_Functions.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "GPIO_Functions");
GPIO__Definitions::module_object.pre_init_module();
TEST__API__Functions::module_object.pre_init_module();
module_object.add_function("f_GPIO_Device_sendValue", (genericfunc_t)&f__GPIO__Device__sendValue, (genericfunc_t)&start_f__GPIO__Device__sendValue);
module_object.add_function("f_GPIO_Device_receiveValue", (genericfunc_t)&f__GPIO__Device__receiveValue, (genericfunc_t)&start_f__GPIO__Device__receiveValue);
module_object.add_function("f_GPIO_TestDevice_receiveExpectedValue", (genericfunc_t)&f__GPIO__TestDevice__receiveExpectedValue, (genericfunc_t)&start_f__GPIO__TestDevice__receiveExpectedValue);
module_object.add_function("f_GPIO_Controller_sendValue", (genericfunc_t)&f__GPIO__Controller__sendValue, (genericfunc_t)&start_f__GPIO__Controller__sendValue);
module_object.add_function("f_GPIO_Controller_receiveValue", (genericfunc_t)&f__GPIO__Controller__receiveValue, (genericfunc_t)&start_f__GPIO__Controller__receiveValue);
}

static void post_init_module()
{
TTCN_Location current_location("GPIO_Functions.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "GPIO_Functions");
GPIO__Definitions::module_object.post_init_module();
TEST__API__Functions::module_object.post_init_module();
}

static boolean start_ptc_function(const char *function_name, Text_Buf& function_arguments)
{
if (!strcmp(function_name, "f_GPIO_Device_sendValue")) {
GPIOPinPort::GPIO__PIN__VALUE newValue;
newValue.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_GPIO_Device_sendValue(");
newValue.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__GPIO__Device__sendValue(newValue);
TTCN_Runtime::function_finished("f_GPIO_Device_sendValue");
return TRUE;
} else if (!strcmp(function_name, "f_GPIO_Device_receiveValue")) {
TTCN_Logger::log_str(TTCN_Logger::PARALLEL_PTC, "Starting function f_GPIO_Device_receiveValue().");
TTCN_Runtime::function_started(function_arguments);
f__GPIO__Device__receiveValue();
TTCN_Runtime::function_finished("f_GPIO_Device_receiveValue");
return TRUE;
} else if (!strcmp(function_name, "f_GPIO_TestDevice_receiveExpectedValue")) {
GPIOPinPort::GPIO__PIN__VALUE expectedValue;
expectedValue.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_GPIO_TestDevice_receiveExpectedValue(");
expectedValue.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__GPIO__TestDevice__receiveExpectedValue(expectedValue);
TTCN_Runtime::function_finished("f_GPIO_TestDevice_receiveExpectedValue");
return TRUE;
} else if (!strcmp(function_name, "f_GPIO_Controller_sendValue")) {
GPIOPinPort::GPIO__PIN__VALUE newValue;
newValue.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_GPIO_Controller_sendValue(");
newValue.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__GPIO__Controller__sendValue(newValue);
TTCN_Runtime::function_finished("f_GPIO_Controller_sendValue");
return TRUE;
} else if (!strcmp(function_name, "f_GPIO_Controller_receiveValue")) {
TTCN_Logger::log_str(TTCN_Logger::PARALLEL_PTC, "Starting function f_GPIO_Controller_receiveValue().");
TTCN_Runtime::function_started(function_arguments);
f__GPIO__Controller__receiveValue();
TTCN_Runtime::function_finished("f_GPIO_Controller_receiveValue");
return TRUE;
} else return FALSE;
}


} /* end of namespace */
