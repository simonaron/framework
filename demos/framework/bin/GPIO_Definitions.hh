// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R3A
// for  (pi@pi-02) on Sat Apr 21 19:03:51 2018

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef GPIO__Definitions_HH
#define GPIO__Definitions_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>
#include "GPIOPinPort.hh"
#include "TEST_API_Definitions.hh"

#if TTCN3_VERSION != 60300
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef GPIO__Definitions_HH
#endif

namespace GPIO__Definitions {

/* Forward declarations of classes */

class PT__GPIO__Device;
class PT__GPIO__Controller;

} /* end of namespace */

#ifndef GPIO__Definitions_HH
#define GPIO__Definitions_HH

namespace GPIO__Definitions {

/* Type definitions */

typedef COMPONENT CT__GPIO__Device;
typedef COMPONENT_template CT__GPIO__Device_template;
typedef COMPONENT CT__GPIO__Controller;
typedef COMPONENT_template CT__GPIO__Controller_template;

/* Class definitions */

class PT__GPIO__Device : public PORT {
enum msg_selection { MESSAGE_0, MESSAGE_1, MESSAGE_2 };
struct msg_queue_item : public msg_queue_item_base {
msg_selection item_selection;
union {
GPIOPinPort::GPIO__PIN__DIRECTION *message_0;
GPIOPinPort::GPIO__PIN__VALUE *message_1;
GPIOPinPort::GPIO__PIN__STATUS *message_2;
};
component sender_component;
};

void remove_msg_queue_head();
protected:
void clear_queue();
public:
PT__GPIO__Device(const char *par_port_name = NULL);
~PT__GPIO__Device();
void send(const GPIOPinPort::GPIO__PIN__VALUE& send_par, const COMPONENT& destination_component);
void send(const GPIOPinPort::GPIO__PIN__VALUE& send_par);
void send(const GPIOPinPort::GPIO__PIN__VALUE_template& send_par, const COMPONENT& destination_component);
void send(const GPIOPinPort::GPIO__PIN__VALUE_template& send_par);
void send(const GPIOPinPort::GPIO__PIN__STATUS& send_par, const COMPONENT& destination_component);
void send(const GPIOPinPort::GPIO__PIN__STATUS& send_par);
void send(const GPIOPinPort::GPIO__PIN__STATUS_template& send_par, const COMPONENT& destination_component);
void send(const GPIOPinPort::GPIO__PIN__STATUS_template& send_par);
public:
alt_status receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status receive(const GPIOPinPort::GPIO__PIN__DIRECTION_template& value_template, GPIOPinPort::GPIO__PIN__DIRECTION *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status check_receive(const GPIOPinPort::GPIO__PIN__DIRECTION_template& value_template, GPIOPinPort::GPIO__PIN__DIRECTION *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status trigger(const GPIOPinPort::GPIO__PIN__DIRECTION_template& value_template, GPIOPinPort::GPIO__PIN__DIRECTION *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status receive(const GPIOPinPort::GPIO__PIN__VALUE_template& value_template, GPIOPinPort::GPIO__PIN__VALUE *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status check_receive(const GPIOPinPort::GPIO__PIN__VALUE_template& value_template, GPIOPinPort::GPIO__PIN__VALUE *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status trigger(const GPIOPinPort::GPIO__PIN__VALUE_template& value_template, GPIOPinPort::GPIO__PIN__VALUE *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status receive(const GPIOPinPort::GPIO__PIN__STATUS_template& value_template, GPIOPinPort::GPIO__PIN__STATUS *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status check_receive(const GPIOPinPort::GPIO__PIN__STATUS_template& value_template, GPIOPinPort::GPIO__PIN__STATUS *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status trigger(const GPIOPinPort::GPIO__PIN__STATUS_template& value_template, GPIOPinPort::GPIO__PIN__STATUS *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
private:
void incoming_message(const GPIOPinPort::GPIO__PIN__DIRECTION& incoming_par, component sender_component);
void incoming_message(const GPIOPinPort::GPIO__PIN__VALUE& incoming_par, component sender_component);
void incoming_message(const GPIOPinPort::GPIO__PIN__STATUS& incoming_par, component sender_component);
protected:
boolean process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING& slider);
};

class PT__GPIO__Controller : public PORT {
enum msg_selection { MESSAGE_0, MESSAGE_1 };
struct msg_queue_item : public msg_queue_item_base {
msg_selection item_selection;
union {
GPIOPinPort::GPIO__PIN__VALUE *message_0;
GPIOPinPort::GPIO__PIN__STATUS *message_1;
};
component sender_component;
};

void remove_msg_queue_head();
protected:
void clear_queue();
public:
PT__GPIO__Controller(const char *par_port_name = NULL);
~PT__GPIO__Controller();
void send(const GPIOPinPort::GPIO__PIN__DIRECTION& send_par, const COMPONENT& destination_component);
void send(const GPIOPinPort::GPIO__PIN__DIRECTION& send_par);
void send(const GPIOPinPort::GPIO__PIN__DIRECTION_template& send_par, const COMPONENT& destination_component);
void send(const GPIOPinPort::GPIO__PIN__DIRECTION_template& send_par);
void send(const GPIOPinPort::GPIO__PIN__VALUE& send_par, const COMPONENT& destination_component);
void send(const GPIOPinPort::GPIO__PIN__VALUE& send_par);
void send(const GPIOPinPort::GPIO__PIN__VALUE_template& send_par, const COMPONENT& destination_component);
void send(const GPIOPinPort::GPIO__PIN__VALUE_template& send_par);
void send(const GPIOPinPort::GPIO__PIN__STATUS& send_par, const COMPONENT& destination_component);
void send(const GPIOPinPort::GPIO__PIN__STATUS& send_par);
void send(const GPIOPinPort::GPIO__PIN__STATUS_template& send_par, const COMPONENT& destination_component);
void send(const GPIOPinPort::GPIO__PIN__STATUS_template& send_par);
public:
alt_status receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status receive(const GPIOPinPort::GPIO__PIN__VALUE_template& value_template, GPIOPinPort::GPIO__PIN__VALUE *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status check_receive(const GPIOPinPort::GPIO__PIN__VALUE_template& value_template, GPIOPinPort::GPIO__PIN__VALUE *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status trigger(const GPIOPinPort::GPIO__PIN__VALUE_template& value_template, GPIOPinPort::GPIO__PIN__VALUE *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status receive(const GPIOPinPort::GPIO__PIN__STATUS_template& value_template, GPIOPinPort::GPIO__PIN__STATUS *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status check_receive(const GPIOPinPort::GPIO__PIN__STATUS_template& value_template, GPIOPinPort::GPIO__PIN__STATUS *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status trigger(const GPIOPinPort::GPIO__PIN__STATUS_template& value_template, GPIOPinPort::GPIO__PIN__STATUS *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
private:
void incoming_message(const GPIOPinPort::GPIO__PIN__VALUE& incoming_par, component sender_component);
void incoming_message(const GPIOPinPort::GPIO__PIN__STATUS& incoming_par, component sender_component);
protected:
boolean process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING& slider);
};


/* Global variable declarations */

extern const TTCN_Typedescriptor_t& CT__GPIO__Device_descr_;
extern PT__GPIO__Device CT__GPIO__Device_component_controller;
extern const TTCN_Typedescriptor_t& CT__GPIO__Controller_descr_;
extern PT__GPIO__Controller CT__GPIO__Controller_component_device;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
