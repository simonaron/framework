// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R3A
// for  (pi@pi-02) on Sat Apr 21 19:03:51 2018

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "TEST_Functions.hh"

namespace TEST__Functions {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();
static boolean start_ptc_function(const char *function_name, Text_Buf& function_arguments);

/* Literal string constants */

static const CHARSTRING cs_0(36, "( inconc )  Receive verdict timeout.");
static const unsigned char module_checksum[] = { 0x8e, 0x16, 0x66, 0x6a, 0xf5, 0x1b, 0xf8, 0x5b, 0xf1, 0x60, 0x32, 0x09, 0xd8, 0x4f, 0x05, 0x0a };

/* Global variable definitions */

static FLOAT const_f__TEST__Watcher__getverdict_new__timeout_defval;
const FLOAT& f__TEST__Watcher__getverdict_new__timeout_defval = const_f__TEST__Watcher__getverdict_new__timeout_defval;
TTCN_Module module_object("TEST_Functions", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, NULL, start_ptc_function, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_3,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Bodies of functions, altsteps and testcases */

void f__TEST__Subject__subscribeWatcher(const COMPONENT& new__watcher)
{
TTCN_Location current_location("TEST_Functions.ttcn", 6, TTCN_Location::LOCATION_FUNCTION, "f_TEST_Subject_subscribeWatcher");
current_location.update_lineno(7);
/* TEST_Functions.ttcn, line 7 */
TTCN_Runtime::connect_port(self, TEST__Definitions::CT__TEST__Subject_component_watcher.get_name(), new__watcher, TEST__Definitions::CT__TEST__Watcher_component_subject.get_name());
current_location.update_lineno(8);
/* TEST_Functions.ttcn, line 8 */
TEST__Definitions::CT__TEST__Subject_component_mode = TEST__Definitions::CT__TEST__SubjectMode::TEST;
}

void start_f__TEST__Subject__subscribeWatcher(const COMPONENT& component_reference, const COMPONENT& new__watcher)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_TEST_Subject_subscribeWatcher(");
new__watcher.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "TEST_Functions", "f_TEST_Subject_subscribeWatcher", text_buf);
new__watcher.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__TEST__Subject__setverdict(const VERDICTTYPE& new__verdict, const CHARSTRING& new__reason)
{
TTCN_Location current_location("TEST_Functions.ttcn", 11, TTCN_Location::LOCATION_FUNCTION, "f_TEST_Subject_setverdict");
current_location.update_lineno(12);
/* TEST_Functions.ttcn, line 12 */
if ((TEST__Definitions::CT__TEST__Subject_component_mode == TEST__Definitions::CT__TEST__SubjectMode::TEST)) {
current_location.update_lineno(13);
/* TEST_Functions.ttcn, line 13 */
{
TEST__Definitions::RT__TEST__Verdict_template tmp_1;
tmp_1.verdict() = new__verdict;
tmp_1.reason() = new__reason;
TEST__Definitions::CT__TEST__Subject_component_watcher.send(tmp_1);
}
}
else {
current_location.update_lineno(14);
/* TEST_Functions.ttcn, line 14 */
if ((TEST__Definitions::CT__TEST__Subject_component_mode == TEST__Definitions::CT__TEST__SubjectMode::LIVE)) {
current_location.update_lineno(15);
/* TEST_Functions.ttcn, line 15 */
try {
TTCN_Logger::begin_event(TTCN_USER);
new__reason.log();
TTCN_Logger::end_event();
} catch (...) {
TTCN_Logger::finish_event();
throw;
}
current_location.update_lineno(16);
/* TEST_Functions.ttcn, line 16 */
TTCN_Runtime::setverdict(new__verdict,(TTCN_Logger::begin_event_log2str(),new__reason.log(),TTCN_Logger::end_event_log2str()));
}
}
}

void start_f__TEST__Subject__setverdict(const COMPONENT& component_reference, const VERDICTTYPE& new__verdict, const CHARSTRING& new__reason)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_TEST_Subject_setverdict(");
new__verdict.log();
TTCN_Logger::log_event_str(", ");
new__reason.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "TEST_Functions", "f_TEST_Subject_setverdict", text_buf);
new__verdict.encode_text(text_buf);
new__reason.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__TEST__Watcher__watch(const COMPONENT& new__subject)
{
TTCN_Location current_location("TEST_Functions.ttcn", 22, TTCN_Location::LOCATION_FUNCTION, "f_TEST_Watcher_watch");
current_location.update_lineno(23);
/* TEST_Functions.ttcn, line 23 */
start_f__TEST__Subject__subscribeWatcher(new__subject, self);
current_location.update_lineno(24);
/* TEST_Functions.ttcn, line 24 */
{
tmp_2:
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = new__subject.done(NULL);
if (alt_flag == ALT_YES) break;
else if (alt_flag == ALT_REPEAT) goto tmp_2;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_2;
}
current_location.update_lineno(24);
/* TEST_Functions.ttcn, line 24 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone done statement failed in file TEST_Functions.ttcn, line 24.");
TTCN_Snapshot::take_new(TRUE);
}
}
}

void start_f__TEST__Watcher__watch(const COMPONENT& component_reference, const COMPONENT& new__subject)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_TEST_Watcher_watch(");
new__subject.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "TEST_Functions", "f_TEST_Watcher_watch", text_buf);
new__subject.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__TEST__Watcher__getverdict(const VERDICTTYPE& expected__verdict, const CHARSTRING& expected__reason, const FLOAT& new__timeout)
{
TTCN_Location current_location("TEST_Functions.ttcn", 27, TTCN_Location::LOCATION_FUNCTION, "f_TEST_Watcher_getverdict");
current_location.update_lineno(28);
/* TEST_Functions.ttcn, line 28 */
TEST__Definitions::RT__TEST__Verdict receivedVerdict;
current_location.update_lineno(29);
/* TEST_Functions.ttcn, line 29 */
TEST__Definitions::RT__TEST__Verdict expectedVerdict;
expectedVerdict.verdict() = expected__verdict;
expectedVerdict.reason() = expected__reason;
current_location.update_lineno(31);
/* TEST_Functions.ttcn, line 31 */
TIMER receive__timer("receive_timer", new__timeout);
current_location.update_lineno(32);
/* TEST_Functions.ttcn, line 32 */
receive__timer.start();
current_location.update_lineno(33);
/* TEST_Functions.ttcn, line 33 */
{
tmp_3:
alt_status tmp_3_alt_flag_0 = ALT_MAYBE;
alt_status tmp_3_alt_flag_1 = ALT_MAYBE;
alt_status tmp_3_alt_flag_2 = ALT_MAYBE;
alt_status tmp_3_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_3_alt_flag_0 == ALT_MAYBE) {
current_location.update_lineno(34);
/* TEST_Functions.ttcn, line 34 */
tmp_3_alt_flag_0 = TEST__Definitions::CT__TEST__Watcher_component_subject.receive(TEST__Definitions::RT__TEST__Verdict_template(expectedVerdict), &(receivedVerdict), any_compref, NULL, NULL);
if (tmp_3_alt_flag_0 == ALT_YES) {
current_location.update_lineno(35);
/* TEST_Functions.ttcn, line 35 */
f__TEST__Subject__setverdict(PASS, (TTCN_Logger::begin_event_log2str(),TTCN_Logger::log_event_str("( pass )  Expected verdict received: "),receivedVerdict.log(),TTCN_Logger::end_event_log2str()));
break;
}
}
if (tmp_3_alt_flag_1 == ALT_MAYBE) {
current_location.update_lineno(37);
/* TEST_Functions.ttcn, line 37 */
tmp_3_alt_flag_1 = TEST__Definitions::CT__TEST__Watcher_component_subject.receive(TEST__Definitions::RT__TEST__Verdict_template(ANY_VALUE), &(receivedVerdict), any_compref, NULL, NULL);
if (tmp_3_alt_flag_1 == ALT_YES) {
current_location.update_lineno(38);
/* TEST_Functions.ttcn, line 38 */
f__TEST__Subject__setverdict(FAIL, (TTCN_Logger::begin_event_log2str(),TTCN_Logger::log_event_str("( fail )  Unexpected verdict received: "),receivedVerdict.log(),TTCN_Logger::log_event_str(" - Expected: "),expectedVerdict.log(),TTCN_Logger::end_event_log2str()));
break;
}
}
if (tmp_3_alt_flag_2 == ALT_MAYBE) {
current_location.update_lineno(40);
/* TEST_Functions.ttcn, line 40 */
tmp_3_alt_flag_2 = receive__timer.timeout(NULL);
if (tmp_3_alt_flag_2 == ALT_YES) {
current_location.update_lineno(41);
/* TEST_Functions.ttcn, line 41 */
f__TEST__Subject__setverdict(INCONC, cs_0);
break;
}
}
if (tmp_3_default_flag == ALT_MAYBE) {
tmp_3_default_flag = TTCN_Default::try_altsteps();
if (tmp_3_default_flag == ALT_YES || tmp_3_default_flag == ALT_BREAK) break;
else if (tmp_3_default_flag == ALT_REPEAT) goto tmp_3;
}
current_location.update_lineno(33);
/* TEST_Functions.ttcn, line 33 */
if (tmp_3_alt_flag_0 == ALT_NO && tmp_3_alt_flag_1 == ALT_NO && tmp_3_alt_flag_2 == ALT_NO && tmp_3_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file TEST_Functions.ttcn between lines 33 and 43.");
TTCN_Snapshot::take_new(TRUE);
}
}
}

void start_f__TEST__Watcher__getverdict(const COMPONENT& component_reference, const VERDICTTYPE& expected__verdict, const CHARSTRING& expected__reason, const FLOAT& new__timeout)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_TEST_Watcher_getverdict(");
expected__verdict.log();
TTCN_Logger::log_event_str(", ");
expected__reason.log();
TTCN_Logger::log_event_str(", ");
new__timeout.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "TEST_Functions", "f_TEST_Watcher_getverdict", text_buf);
expected__verdict.encode_text(text_buf);
expected__reason.encode_text(text_buf);
new__timeout.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("TEST_Functions.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "TEST_Functions");
TEST__Definitions::module_object.pre_init_module();
module_object.add_function("f_TEST_Subject_subscribeWatcher", (genericfunc_t)&f__TEST__Subject__subscribeWatcher, (genericfunc_t)&start_f__TEST__Subject__subscribeWatcher);
module_object.add_function("f_TEST_Subject_setverdict", (genericfunc_t)&f__TEST__Subject__setverdict, (genericfunc_t)&start_f__TEST__Subject__setverdict);
module_object.add_function("f_TEST_Watcher_watch", (genericfunc_t)&f__TEST__Watcher__watch, (genericfunc_t)&start_f__TEST__Watcher__watch);
module_object.add_function("f_TEST_Watcher_getverdict", (genericfunc_t)&f__TEST__Watcher__getverdict, (genericfunc_t)&start_f__TEST__Watcher__getverdict);
}

static void post_init_module()
{
TTCN_Location current_location("TEST_Functions.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "TEST_Functions");
TEST__Definitions::module_object.post_init_module();
const_f__TEST__Watcher__getverdict_new__timeout_defval = 1.0;
}

static boolean start_ptc_function(const char *function_name, Text_Buf& function_arguments)
{
if (!strcmp(function_name, "f_TEST_Subject_subscribeWatcher")) {
COMPONENT new__watcher;
new__watcher.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_TEST_Subject_subscribeWatcher(");
new__watcher.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__TEST__Subject__subscribeWatcher(new__watcher);
TTCN_Runtime::function_finished("f_TEST_Subject_subscribeWatcher");
return TRUE;
} else if (!strcmp(function_name, "f_TEST_Subject_setverdict")) {
VERDICTTYPE new__verdict;
CHARSTRING new__reason;
new__verdict.decode_text(function_arguments);
new__reason.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_TEST_Subject_setverdict(");
new__verdict.log();
TTCN_Logger::log_event_str(", ");
new__reason.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__TEST__Subject__setverdict(new__verdict, new__reason);
TTCN_Runtime::function_finished("f_TEST_Subject_setverdict");
return TRUE;
} else if (!strcmp(function_name, "f_TEST_Watcher_watch")) {
COMPONENT new__subject;
new__subject.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_TEST_Watcher_watch(");
new__subject.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__TEST__Watcher__watch(new__subject);
TTCN_Runtime::function_finished("f_TEST_Watcher_watch");
return TRUE;
} else if (!strcmp(function_name, "f_TEST_Watcher_getverdict")) {
VERDICTTYPE expected__verdict;
CHARSTRING expected__reason;
FLOAT new__timeout;
expected__verdict.decode_text(function_arguments);
expected__reason.decode_text(function_arguments);
new__timeout.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_TEST_Watcher_getverdict(");
expected__verdict.log();
TTCN_Logger::log_event_str(", ");
expected__reason.log();
TTCN_Logger::log_event_str(", ");
new__timeout.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__TEST__Watcher__getverdict(expected__verdict, expected__reason, new__timeout);
TTCN_Runtime::function_finished("f_TEST_Watcher_getverdict");
return TRUE;
} else return FALSE;
}


} /* end of namespace */
