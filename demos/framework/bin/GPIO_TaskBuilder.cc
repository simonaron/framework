// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R3A
// for  (pi@pi-02) on Sat Apr 21 19:03:51 2018

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "GPIO_TaskBuilder.hh"

namespace GPIO__TaskBuilder {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();
static boolean init_comp_type(const char *component_type, boolean init_base_comps);
static boolean start_ptc_function(const char *function_name, Text_Buf& function_arguments);

/* Literal string constants */

static const unsigned char module_checksum[] = { 0x8a, 0xe9, 0xd1, 0xba, 0xb7, 0xc8, 0x6f, 0xa4, 0x00, 0xd4, 0x8e, 0x7e, 0xc0, 0xec, 0x5d, 0xba };

/* Global variable definitions */

const TTCN_Typedescriptor_t& CT__GPIO__TaskBuilder_descr_ = COMPONENT_descr_;
TTCN_Module module_object("GPIO_TaskBuilder", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, init_comp_type, start_ptc_function, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_3,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Bodies of functions, altsteps and testcases */

void f__GPIO__TaskBuilder(const COMPONENT& interfaceStore)
{
TTCN_Location current_location("GPIO_TaskBuilder.ttcn", 12, TTCN_Location::LOCATION_FUNCTION, "f_GPIO_TaskBuilder");
current_location.update_lineno(14);
/* GPIO_TaskBuilder.ttcn, line 14 */
TTCN_Runtime::connect_port(self, TASK__BUILDER::CT__TASK__BUILDER__TaskBuilder_component_p__interfaceStore.get_name(), interfaceStore, INTERFACE__STORE::CT__INTERFACE__STORE__InterfaceStore_component_p__interfaceStoreClient.get_name());
current_location.update_lineno(15);
/* GPIO_TaskBuilder.ttcn, line 15 */
GPIO__ReceiveValueTask::activate_as__GPIO__ReceiveValueTask__TaskBuilder__subscribe();
current_location.update_lineno(16);
/* GPIO_TaskBuilder.ttcn, line 16 */
GPIO__SendValueTask::activate_as__GPIO__SendValueTask__TaskBuilder__subscribe();
current_location.update_lineno(18);
/* GPIO_TaskBuilder.ttcn, line 18 */
{
tmp_0:
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = TASK::CT__TASK__Task_component_p__taskPort.receive(TASK::ET__TASK__ControlIncomingMessage_template(TASK::ET__TASK__ControlIncomingMessage::EV__TASK__STOP), NULL, any_compref, NULL, NULL);
if (alt_flag == ALT_YES) break;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_0;
}
current_location.update_lineno(18);
/* GPIO_TaskBuilder.ttcn, line 18 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone receive statement failed in file GPIO_TaskBuilder.ttcn, line 18.");
TTCN_Snapshot::take_new(TRUE);
}
}
}

void start_f__GPIO__TaskBuilder(const COMPONENT& component_reference, const COMPONENT& interfaceStore)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_GPIO_TaskBuilder(");
interfaceStore.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "GPIO_TaskBuilder", "f_GPIO_TaskBuilder", text_buf);
interfaceStore.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("GPIO_TaskBuilder.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "GPIO_TaskBuilder");
TEST__API__Definitions::module_object.pre_init_module();
TASK__BUILDER::module_object.pre_init_module();
INTERFACE__STORE::module_object.pre_init_module();
GPIO__ReceiveValueTask::module_object.pre_init_module();
GPIO__SendValueTask::module_object.pre_init_module();
module_object.add_function("f_GPIO_TaskBuilder", (genericfunc_t)&f__GPIO__TaskBuilder, (genericfunc_t)&start_f__GPIO__TaskBuilder);
}

static void post_init_module()
{
TTCN_Location current_location("GPIO_TaskBuilder.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "GPIO_TaskBuilder");
TEST__API__Definitions::module_object.post_init_module();
TASK__BUILDER::module_object.post_init_module();
INTERFACE__STORE::module_object.post_init_module();
GPIO__ReceiveValueTask::module_object.post_init_module();
GPIO__SendValueTask::module_object.post_init_module();
}

static boolean init_comp_type(const char *component_type, boolean init_base_comps)
{
(void)init_base_comps;
if (!strcmp(component_type, "CT_GPIO_TaskBuilder")) {
if (init_base_comps) {
Module_List::initialize_component("TASK", "CT_TASK_Task", FALSE);
Module_List::initialize_component("TEST_Definitions", "CT_TEST_Subject", FALSE);
Module_List::initialize_component("TASK_BUILDER", "CT_TASK_BUILDER_TaskBuilder", FALSE);
}
return TRUE;
} else return FALSE;
}

static boolean start_ptc_function(const char *function_name, Text_Buf& function_arguments)
{
if (!strcmp(function_name, "f_GPIO_TaskBuilder")) {
COMPONENT interfaceStore;
interfaceStore.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_GPIO_TaskBuilder(");
interfaceStore.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__GPIO__TaskBuilder(interfaceStore);
TTCN_Runtime::function_finished("f_GPIO_TaskBuilder");
return TRUE;
} else return FALSE;
}


} /* end of namespace */
