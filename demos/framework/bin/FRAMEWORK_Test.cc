// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R3A
// for  (pi@pi-02) on Sun Apr 22 14:46:24 2018

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "FRAMEWORK_Test.hh"

namespace FRAMEWORK__Test {

/* Prototypes of static functions */

static void pre_init_module();
static void post_init_module();
static boolean init_comp_type(const char *component_type, boolean init_base_comps);
static boolean start_ptc_function(const char *function_name, Text_Buf& function_arguments);
static void module_control_part();

/* Literal string constants */

static const CHARSTRING cs_0(6, "ENABLE"),
cs_3(4, "HIGH"),
cs_1(2, "IN"),
cs_4(3, "LOW"),
cs_2(7, "receive");
static const unsigned char module_checksum[] = { 0x60, 0x36, 0x9c, 0x9c, 0x44, 0x39, 0x06, 0xa6, 0xd3, 0x7e, 0xf1, 0x53, 0x5e, 0x33, 0x22, 0xd9 };

/* Global variable definitions */

const TTCN_Typedescriptor_t& CT__GPIO__Proxy_descr_ = COMPONENT_descr_;
const TTCN_Typedescriptor_t& MTC_descr_ = COMPONENT_descr_;
TASK::PT__TASK__TaskExecutorPort MTC_component_p__task("p_task");
TTCN_Module module_object("FRAMEWORK_Test", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, post_init_module, NULL, NULL, NULL, init_comp_type, start_ptc_function, module_control_part);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_3,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Bodies of functions, altsteps and testcases */

void f__GPIO__OutProxy(const INTEGER& index)
{
TTCN_Location current_location("FRAMEWORK_Test.ttcn", 11, TTCN_Location::LOCATION_FUNCTION, "f_GPIO_OutProxy");
current_location.update_lineno(13);
/* FRAMEWORK_Test.ttcn, line 13 */
TTCN_Runtime::map_port(self, GPIOPinPort::GPIO__Base_component_gpio[index].get_name(), SYSTEM_COMPREF, get_port_name("gpio", index));
current_location.update_lineno(14);
/* FRAMEWORK_Test.ttcn, line 14 */
TIMER t("t");
current_location.update_lineno(14);
/* FRAMEWORK_Test.ttcn, line 14 */
t.start(1.0e-1);
current_location.update_lineno(14);
/* FRAMEWORK_Test.ttcn, line 14 */
{
tmp_0:
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = t.timeout(NULL);
if (alt_flag == ALT_YES) break;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_0;
}
current_location.update_lineno(14);
/* FRAMEWORK_Test.ttcn, line 14 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone timeout statement failed in file FRAMEWORK_Test.ttcn, line 14.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(15);
/* FRAMEWORK_Test.ttcn, line 15 */
GPIOPinPort::GPIO__Base_component_gpio[index].send(GPIOPinPort::GPIO__PIN__DIRECTION(GPIOPinPort::GPIO__PIN__DIRECTION::OUT));
current_location.update_lineno(16);
/* FRAMEWORK_Test.ttcn, line 16 */
t.start(1.0e-1);
current_location.update_lineno(16);
/* FRAMEWORK_Test.ttcn, line 16 */
{
tmp_1:
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = t.timeout(NULL);
if (alt_flag == ALT_YES) break;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_1;
}
current_location.update_lineno(16);
/* FRAMEWORK_Test.ttcn, line 16 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone timeout statement failed in file FRAMEWORK_Test.ttcn, line 16.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(17);
/* FRAMEWORK_Test.ttcn, line 17 */
TTCN_Logger::log_str(TTCN_USER, "NAGYON NAGYON KISCICA");
current_location.update_lineno(18);
/* FRAMEWORK_Test.ttcn, line 18 */
GPIOPinPort::GPIO__PIN__VALUE v__value;
current_location.update_lineno(19);
/* FRAMEWORK_Test.ttcn, line 19 */
{
tmp_2:
alt_status tmp_2_alt_flag_0 = ALT_MAYBE;
alt_status tmp_2_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_2_alt_flag_0 == ALT_MAYBE) {
current_location.update_lineno(20);
/* FRAMEWORK_Test.ttcn, line 20 */
tmp_2_alt_flag_0 = GPIO__Definitions::CT__GPIO__Device_component_controller.receive(GPIOPinPort::GPIO__PIN__VALUE_template(ANY_VALUE), &(v__value), any_compref, NULL, NULL);
if (tmp_2_alt_flag_0 == ALT_YES) {
current_location.update_lineno(21);
/* FRAMEWORK_Test.ttcn, line 21 */
GPIOPinPort::GPIO__Base_component_gpio[index].send(v__value);
current_location.update_lineno(22);
/* FRAMEWORK_Test.ttcn, line 22 */
goto tmp_2;
}
}
if (tmp_2_default_flag == ALT_MAYBE) {
tmp_2_default_flag = TTCN_Default::try_altsteps();
if (tmp_2_default_flag == ALT_YES || tmp_2_default_flag == ALT_BREAK) break;
else if (tmp_2_default_flag == ALT_REPEAT) goto tmp_2;
}
current_location.update_lineno(19);
/* FRAMEWORK_Test.ttcn, line 19 */
if (tmp_2_alt_flag_0 == ALT_NO && tmp_2_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file FRAMEWORK_Test.ttcn between lines 19 and 24.");
TTCN_Snapshot::take_new(TRUE);
}
}
}

void start_f__GPIO__OutProxy(const COMPONENT& component_reference, const INTEGER& index)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_GPIO_OutProxy(");
index.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "FRAMEWORK_Test", "f_GPIO_OutProxy", text_buf);
index.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__GPIO__InProxy(const INTEGER& index)
{
TTCN_Location current_location("FRAMEWORK_Test.ttcn", 27, TTCN_Location::LOCATION_FUNCTION, "f_GPIO_InProxy");
current_location.update_lineno(29);
/* FRAMEWORK_Test.ttcn, line 29 */
TTCN_Runtime::map_port(self, GPIOPinPort::GPIO__Base_component_gpio[index].get_name(), SYSTEM_COMPREF, get_port_name("gpio", index));
current_location.update_lineno(30);
/* FRAMEWORK_Test.ttcn, line 30 */
TIMER t("t");
current_location.update_lineno(30);
/* FRAMEWORK_Test.ttcn, line 30 */
t.start(1.0e-1);
current_location.update_lineno(30);
/* FRAMEWORK_Test.ttcn, line 30 */
{
tmp_3:
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = t.timeout(NULL);
if (alt_flag == ALT_YES) break;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_3;
}
current_location.update_lineno(30);
/* FRAMEWORK_Test.ttcn, line 30 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone timeout statement failed in file FRAMEWORK_Test.ttcn, line 30.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(31);
/* FRAMEWORK_Test.ttcn, line 31 */
GPIOPinPort::GPIO__Base_component_gpio[index].send(GPIOPinPort::GPIO__PIN__DIRECTION(GPIOPinPort::GPIO__PIN__DIRECTION::IN));
current_location.update_lineno(32);
/* FRAMEWORK_Test.ttcn, line 32 */
t.start(1.0e-1);
current_location.update_lineno(32);
/* FRAMEWORK_Test.ttcn, line 32 */
{
tmp_4:
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = t.timeout(NULL);
if (alt_flag == ALT_YES) break;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_4;
}
current_location.update_lineno(32);
/* FRAMEWORK_Test.ttcn, line 32 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone timeout statement failed in file FRAMEWORK_Test.ttcn, line 32.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(33);
/* FRAMEWORK_Test.ttcn, line 33 */
TTCN_Logger::log_str(TTCN_USER, "NAGYON NAGYON KISCICA");
current_location.update_lineno(34);
/* FRAMEWORK_Test.ttcn, line 34 */
GPIOPinPort::GPIO__PIN__VALUE v__value;
current_location.update_lineno(35);
/* FRAMEWORK_Test.ttcn, line 35 */
{
tmp_5:
alt_status tmp_5_alt_flag_0 = ALT_MAYBE;
alt_status tmp_5_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_5_alt_flag_0 == ALT_MAYBE) {
current_location.update_lineno(36);
/* FRAMEWORK_Test.ttcn, line 36 */
tmp_5_alt_flag_0 = GPIOPinPort::GPIO__Base_component_gpio[index].receive(GPIOPinPort::GPIO__PIN__VALUE_template(ANY_VALUE), &(v__value), any_compref, NULL, NULL);
if (tmp_5_alt_flag_0 == ALT_YES) {
current_location.update_lineno(37);
/* FRAMEWORK_Test.ttcn, line 37 */
GPIO__Definitions::CT__GPIO__Device_component_controller.send(v__value);
current_location.update_lineno(38);
/* FRAMEWORK_Test.ttcn, line 38 */
goto tmp_5;
}
}
if (tmp_5_default_flag == ALT_MAYBE) {
tmp_5_default_flag = TTCN_Default::try_altsteps();
if (tmp_5_default_flag == ALT_YES || tmp_5_default_flag == ALT_BREAK) break;
else if (tmp_5_default_flag == ALT_REPEAT) goto tmp_5;
}
current_location.update_lineno(35);
/* FRAMEWORK_Test.ttcn, line 35 */
if (tmp_5_alt_flag_0 == ALT_NO && tmp_5_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file FRAMEWORK_Test.ttcn between lines 35 and 40.");
TTCN_Snapshot::take_new(TRUE);
}
}
}

void start_f__GPIO__InProxy(const COMPONENT& component_reference, const INTEGER& index)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_GPIO_InProxy(");
index.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "FRAMEWORK_Test", "f_GPIO_InProxy", text_buf);
index.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

void f__GPIO__Proxy(const INTEGER& index)
{
TTCN_Location current_location("FRAMEWORK_Test.ttcn", 43, TTCN_Location::LOCATION_FUNCTION, "f_GPIO_Proxy");
current_location.update_lineno(45);
/* FRAMEWORK_Test.ttcn, line 45 */
GPIOPinPort::GPIO__PIN__VALUE v__value;
current_location.update_lineno(46);
/* FRAMEWORK_Test.ttcn, line 46 */
TIMER t("t");
current_location.update_lineno(48);
/* FRAMEWORK_Test.ttcn, line 48 */
{
tmp_6:
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = TASK::CT__TASK__Task_component_p__taskPort.receive(TASK::ET__TASK__ControlIncomingMessage_template(TASK::ET__TASK__ControlIncomingMessage::EV__TASK__INIT), NULL, any_compref, NULL, NULL);
if (alt_flag == ALT_YES) break;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_6;
}
current_location.update_lineno(48);
/* FRAMEWORK_Test.ttcn, line 48 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone receive statement failed in file FRAMEWORK_Test.ttcn, line 48.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(49);
/* FRAMEWORK_Test.ttcn, line 49 */
TTCN_Runtime::map_port(self, GPIOPinPort::GPIO__Base_component_gpio[index].get_name(), SYSTEM_COMPREF, get_port_name("gpio", index));
current_location.update_lineno(50);
/* FRAMEWORK_Test.ttcn, line 50 */
t.start(1.0e-1);
current_location.update_lineno(50);
/* FRAMEWORK_Test.ttcn, line 50 */
{
tmp_7:
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = t.timeout(NULL);
if (alt_flag == ALT_YES) break;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_7;
}
current_location.update_lineno(50);
/* FRAMEWORK_Test.ttcn, line 50 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone timeout statement failed in file FRAMEWORK_Test.ttcn, line 50.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(52);
/* FRAMEWORK_Test.ttcn, line 52 */
GPIOPinPort::GPIO__Base_component_gpio[index].send(GPIOPinPort::GPIO__PIN__DIRECTION(GPIOPinPort::GPIO__PIN__DIRECTION::IN));
current_location.update_lineno(53);
/* FRAMEWORK_Test.ttcn, line 53 */
t.start(1.0e-1);
current_location.update_lineno(53);
/* FRAMEWORK_Test.ttcn, line 53 */
{
tmp_8:
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = t.timeout(NULL);
if (alt_flag == ALT_YES) break;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_8;
}
current_location.update_lineno(53);
/* FRAMEWORK_Test.ttcn, line 53 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone timeout statement failed in file FRAMEWORK_Test.ttcn, line 53.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(54);
/* FRAMEWORK_Test.ttcn, line 54 */
TASK::CT__TASK__Task_component_p__taskPort.send(TASK::ET__TASK__ControlOutcomingMessage(TASK::ET__TASK__ControlOutcomingMessage::EV__TASK__INITIALISED));
current_location.update_lineno(55);
/* FRAMEWORK_Test.ttcn, line 55 */
TTCN_Runtime::begin_action();
TTCN_Logger::log_event_str("ASDASDASDASDASDASD");
TTCN_Runtime::end_action();
current_location.update_lineno(56);
/* FRAMEWORK_Test.ttcn, line 56 */
{
tmp_9:
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = TASK::CT__TASK__Task_component_p__taskPort.receive(TASK::ET__TASK__ControlIncomingMessage_template(TASK::ET__TASK__ControlIncomingMessage::EV__TASK__START), NULL, any_compref, NULL, NULL);
if (alt_flag == ALT_YES) break;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_9;
}
current_location.update_lineno(56);
/* FRAMEWORK_Test.ttcn, line 56 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone receive statement failed in file FRAMEWORK_Test.ttcn, line 56.");
TTCN_Snapshot::take_new(TRUE);
}
}
for ( ; ; ) {
current_location.update_lineno(59);
/* FRAMEWORK_Test.ttcn, line 59 */
{
tmp_10:
alt_status tmp_10_alt_flag_0 = ALT_MAYBE;
alt_status tmp_10_alt_flag_1 = ALT_MAYBE;
alt_status tmp_10_alt_flag_2 = ALT_MAYBE;
alt_status tmp_10_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_10_alt_flag_0 == ALT_MAYBE) {
current_location.update_lineno(60);
/* FRAMEWORK_Test.ttcn, line 60 */
tmp_10_alt_flag_0 = GPIO__Definitions::CT__GPIO__Device_component_controller.receive(GPIOPinPort::GPIO__PIN__DIRECTION_template(GPIOPinPort::GPIO__PIN__DIRECTION::OUT), NULL, any_compref, NULL, NULL);
if (tmp_10_alt_flag_0 == ALT_YES) {
current_location.update_lineno(61);
/* FRAMEWORK_Test.ttcn, line 61 */
GPIOPinPort::GPIO__Base_component_gpio[index].send(GPIOPinPort::GPIO__PIN__DIRECTION(GPIOPinPort::GPIO__PIN__DIRECTION::OUT));
current_location.update_lineno(62);
/* FRAMEWORK_Test.ttcn, line 62 */
t.start(1.0e-1);
current_location.update_lineno(62);
/* FRAMEWORK_Test.ttcn, line 62 */
{
tmp_11:
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = t.timeout(NULL);
if (alt_flag == ALT_YES) break;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_11;
}
current_location.update_lineno(62);
/* FRAMEWORK_Test.ttcn, line 62 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone timeout statement failed in file FRAMEWORK_Test.ttcn, line 62.");
TTCN_Snapshot::take_new(TRUE);
}
}
break;
}
}
if (tmp_10_alt_flag_1 == ALT_MAYBE) {
current_location.update_lineno(64);
/* FRAMEWORK_Test.ttcn, line 64 */
tmp_10_alt_flag_1 = GPIOPinPort::GPIO__Base_component_gpio[index].receive(GPIOPinPort::GPIO__PIN__VALUE_template(ANY_VALUE), &(v__value), any_compref, NULL, NULL);
if (tmp_10_alt_flag_1 == ALT_YES) {
current_location.update_lineno(65);
/* FRAMEWORK_Test.ttcn, line 65 */
TTCN_Runtime::begin_action();
TTCN_Logger::log_event_str("1111111111111111111111111");
TTCN_Runtime::end_action();
current_location.update_lineno(66);
/* FRAMEWORK_Test.ttcn, line 66 */
GPIO__Definitions::CT__GPIO__Device_component_controller.send(v__value);
current_location.update_lineno(67);
/* FRAMEWORK_Test.ttcn, line 67 */
TTCN_Runtime::begin_action();
TTCN_Logger::log_event_str("1111111111111111111111111");
TTCN_Runtime::end_action();
current_location.update_lineno(68);
/* FRAMEWORK_Test.ttcn, line 68 */
goto tmp_10;
}
}
if (tmp_10_alt_flag_2 == ALT_MAYBE) {
current_location.update_lineno(70);
/* FRAMEWORK_Test.ttcn, line 70 */
tmp_10_alt_flag_2 = TASK::CT__TASK__Task_component_p__taskPort.receive(TASK::ET__TASK__ControlIncomingMessage_template(TASK::ET__TASK__ControlIncomingMessage::EV__TASK__STOP), NULL, any_compref, NULL, NULL);
if (tmp_10_alt_flag_2 == ALT_YES) {
current_location.update_lineno(71);
/* FRAMEWORK_Test.ttcn, line 71 */
break;
}
}
if (tmp_10_default_flag == ALT_MAYBE) {
tmp_10_default_flag = TTCN_Default::try_altsteps();
if (tmp_10_default_flag == ALT_YES || tmp_10_default_flag == ALT_BREAK) break;
else if (tmp_10_default_flag == ALT_REPEAT) goto tmp_10;
}
current_location.update_lineno(59);
/* FRAMEWORK_Test.ttcn, line 59 */
if (tmp_10_alt_flag_0 == ALT_NO && tmp_10_alt_flag_1 == ALT_NO && tmp_10_alt_flag_2 == ALT_NO && tmp_10_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file FRAMEWORK_Test.ttcn between lines 59 and 73.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(75);
/* FRAMEWORK_Test.ttcn, line 75 */
{
tmp_12:
alt_status tmp_12_alt_flag_0 = ALT_MAYBE;
alt_status tmp_12_alt_flag_1 = ALT_MAYBE;
alt_status tmp_12_alt_flag_2 = ALT_MAYBE;
alt_status tmp_12_default_flag = ALT_MAYBE;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (tmp_12_alt_flag_0 == ALT_MAYBE) {
current_location.update_lineno(76);
/* FRAMEWORK_Test.ttcn, line 76 */
tmp_12_alt_flag_0 = GPIO__Definitions::CT__GPIO__Device_component_controller.receive(GPIOPinPort::GPIO__PIN__VALUE_template(ANY_VALUE), &(v__value), any_compref, NULL, NULL);
if (tmp_12_alt_flag_0 == ALT_YES) {
current_location.update_lineno(77);
/* FRAMEWORK_Test.ttcn, line 77 */
GPIOPinPort::GPIO__Base_component_gpio[index].send(v__value);
current_location.update_lineno(78);
/* FRAMEWORK_Test.ttcn, line 78 */
goto tmp_12;
}
}
if (tmp_12_alt_flag_1 == ALT_MAYBE) {
current_location.update_lineno(80);
/* FRAMEWORK_Test.ttcn, line 80 */
tmp_12_alt_flag_1 = GPIO__Definitions::CT__GPIO__Device_component_controller.receive(GPIOPinPort::GPIO__PIN__DIRECTION_template(GPIOPinPort::GPIO__PIN__DIRECTION::IN), NULL, any_compref, NULL, NULL);
if (tmp_12_alt_flag_1 == ALT_YES) {
current_location.update_lineno(81);
/* FRAMEWORK_Test.ttcn, line 81 */
GPIOPinPort::GPIO__Base_component_gpio[index].send(GPIOPinPort::GPIO__PIN__DIRECTION(GPIOPinPort::GPIO__PIN__DIRECTION::IN));
current_location.update_lineno(82);
/* FRAMEWORK_Test.ttcn, line 82 */
t.start(1.0e-1);
current_location.update_lineno(82);
/* FRAMEWORK_Test.ttcn, line 82 */
{
tmp_13:
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = t.timeout(NULL);
if (alt_flag == ALT_YES) break;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_13;
}
current_location.update_lineno(82);
/* FRAMEWORK_Test.ttcn, line 82 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone timeout statement failed in file FRAMEWORK_Test.ttcn, line 82.");
TTCN_Snapshot::take_new(TRUE);
}
}
break;
}
}
if (tmp_12_alt_flag_2 == ALT_MAYBE) {
current_location.update_lineno(84);
/* FRAMEWORK_Test.ttcn, line 84 */
tmp_12_alt_flag_2 = TASK::CT__TASK__Task_component_p__taskPort.receive(TASK::ET__TASK__ControlIncomingMessage_template(TASK::ET__TASK__ControlIncomingMessage::EV__TASK__STOP), NULL, any_compref, NULL, NULL);
if (tmp_12_alt_flag_2 == ALT_YES) {
current_location.update_lineno(85);
/* FRAMEWORK_Test.ttcn, line 85 */
GPIOPinPort::GPIO__Base_component_gpio[index].send(GPIOPinPort::GPIO__PIN__DIRECTION(GPIOPinPort::GPIO__PIN__DIRECTION::IN));
current_location.update_lineno(86);
/* FRAMEWORK_Test.ttcn, line 86 */
break;
}
}
if (tmp_12_default_flag == ALT_MAYBE) {
tmp_12_default_flag = TTCN_Default::try_altsteps();
if (tmp_12_default_flag == ALT_YES || tmp_12_default_flag == ALT_BREAK) break;
else if (tmp_12_default_flag == ALT_REPEAT) goto tmp_12;
}
current_location.update_lineno(75);
/* FRAMEWORK_Test.ttcn, line 75 */
if (tmp_12_alt_flag_0 == ALT_NO && tmp_12_alt_flag_1 == ALT_NO && tmp_12_alt_flag_2 == ALT_NO && tmp_12_default_flag == ALT_NO) TTCN_error("None of the branches can be chosen in the alt statement in file FRAMEWORK_Test.ttcn between lines 75 and 88.");
TTCN_Snapshot::take_new(TRUE);
}
}
}
}

void start_f__GPIO__Proxy(const COMPONENT& component_reference, const INTEGER& index)
{
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_GPIO_Proxy(");
index.log();
TTCN_Logger::log_event_str(") on component ");
component_reference.log();
TTCN_Logger::log_char('.');
TTCN_Logger::end_event();
Text_Buf text_buf;
TTCN_Runtime::prepare_start_component(component_reference, "FRAMEWORK_Test", "f_GPIO_Proxy", text_buf);
index.encode_text(text_buf);
TTCN_Runtime::send_start_component(text_buf);
}

verdicttype testcase_test(boolean has_timer, double timer_value)
{
TTCN_Runtime::check_begin_testcase(has_timer, timer_value);
TTCN_Location current_location("FRAMEWORK_Test.ttcn", 96, TTCN_Location::LOCATION_TESTCASE, "test");
try {
TTCN_Runtime::begin_testcase("FRAMEWORK_Test", "test", "FRAMEWORK_Test", "MTC", "FRAMEWORK_Test", "MTC", has_timer, timer_value);
current_location.update_lineno(98);
/* FRAMEWORK_Test.ttcn, line 98 */
COMPONENT device1(TTCN_Runtime::create_component("FRAMEWORK_Test", "CT_GPIO_Proxy", NULL, NULL, TRUE));
current_location.update_lineno(99);
/* FRAMEWORK_Test.ttcn, line 99 */
COMPONENT device2(TTCN_Runtime::create_component("FRAMEWORK_Test", "CT_GPIO_Proxy", NULL, NULL, TRUE));
current_location.update_lineno(101);
/* FRAMEWORK_Test.ttcn, line 101 */
COMPONENT builder(TTCN_Runtime::create_component("GPIO_TaskBuilder", "CT_GPIO_TaskBuilder", NULL, NULL, TRUE));
current_location.update_lineno(102);
/* FRAMEWORK_Test.ttcn, line 102 */
COMPONENT store(TTCN_Runtime::create_component("INTERFACE_STORE", "CT_INTERFACE_STORE_InterfaceStore", NULL, NULL, TRUE));
current_location.update_lineno(103);
/* FRAMEWORK_Test.ttcn, line 103 */
COMPONENT executor(TTCN_Runtime::create_component("SEQUENCE_EXECUTOR", "CT_SEQUENCE_EXECUTOR_SequenceExecutor", NULL, NULL, TRUE));
current_location.update_lineno(106);
/* FRAMEWORK_Test.ttcn, line 106 */
INTERFACE__STORE::start_f__INTERFACE__STORE__InterfaceStore(store);
current_location.update_lineno(109);
/* FRAMEWORK_Test.ttcn, line 109 */
TTCN_Runtime::connect_port(self, INTERFACE__STORE::CT__INTERFACE__STORE__InterfaceStoreClient_component_p__interfaceStore.get_name(), store, INTERFACE__STORE::CT__INTERFACE__STORE__InterfaceStore_component_p__interfaceStoreClient.get_name());
current_location.update_lineno(110);
/* FRAMEWORK_Test.ttcn, line 110 */
{
INTERFACE__STORE::RT__INTERFACE__STORE__InterfaceElement_template tmp_14;
tmp_14.Name() = cs_0;
tmp_14.Device().UV__GPIO() = device1;
tmp_14.Controller() = OMIT_VALUE;
INTERFACE__STORE::CT__INTERFACE__STORE__InterfaceStoreClient_component_p__interfaceStore.send(tmp_14);
}
current_location.update_lineno(111);
/* FRAMEWORK_Test.ttcn, line 111 */
{
INTERFACE__STORE::RT__INTERFACE__STORE__InterfaceElement_template tmp_15;
tmp_15.Name() = cs_1;
tmp_15.Device().UV__GPIO() = device2;
tmp_15.Controller() = OMIT_VALUE;
INTERFACE__STORE::CT__INTERFACE__STORE__InterfaceStoreClient_component_p__interfaceStore.send(tmp_15);
}
current_location.update_lineno(114);
/* FRAMEWORK_Test.ttcn, line 114 */
GPIO__TaskBuilder::start_f__GPIO__TaskBuilder(builder, store);
current_location.update_lineno(117);
/* FRAMEWORK_Test.ttcn, line 117 */
start_f__GPIO__Proxy(device1, 4);
current_location.update_lineno(118);
/* FRAMEWORK_Test.ttcn, line 118 */
start_f__GPIO__Proxy(device2, 17);
current_location.update_lineno(119);
/* FRAMEWORK_Test.ttcn, line 119 */
TTCN_Runtime::connect_port(device1, TASK::CT__TASK__Task_component_p__taskPort.get_name(), self, MTC_component_p__task.get_name());
current_location.update_lineno(120);
/* FRAMEWORK_Test.ttcn, line 120 */
TTCN_Runtime::connect_port(device2, TASK::CT__TASK__Task_component_p__taskPort.get_name(), self, MTC_component_p__task.get_name());
current_location.update_lineno(121);
/* FRAMEWORK_Test.ttcn, line 121 */
MTC_component_p__task.send(TASK::ET__TASK__ControlIncomingMessage(TASK::ET__TASK__ControlIncomingMessage::EV__TASK__INIT), device1);
current_location.update_lineno(122);
/* FRAMEWORK_Test.ttcn, line 122 */
MTC_component_p__task.send(TASK::ET__TASK__ControlIncomingMessage(TASK::ET__TASK__ControlIncomingMessage::EV__TASK__INIT), device2);
current_location.update_lineno(123);
/* FRAMEWORK_Test.ttcn, line 123 */
{
tmp_16:
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = MTC_component_p__task.receive(TASK::ET__TASK__ControlOutcomingMessage_template(TASK::ET__TASK__ControlOutcomingMessage::EV__TASK__INITIALISED), NULL, any_compref, NULL, NULL);
if (alt_flag == ALT_YES) break;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_16;
}
current_location.update_lineno(123);
/* FRAMEWORK_Test.ttcn, line 123 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone receive statement failed in file FRAMEWORK_Test.ttcn, line 123.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(124);
/* FRAMEWORK_Test.ttcn, line 124 */
{
tmp_17:
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = MTC_component_p__task.receive(TASK::ET__TASK__ControlOutcomingMessage_template(TASK::ET__TASK__ControlOutcomingMessage::EV__TASK__INITIALISED), NULL, any_compref, NULL, NULL);
if (alt_flag == ALT_YES) break;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_17;
}
current_location.update_lineno(124);
/* FRAMEWORK_Test.ttcn, line 124 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone receive statement failed in file FRAMEWORK_Test.ttcn, line 124.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(125);
/* FRAMEWORK_Test.ttcn, line 125 */
MTC_component_p__task.send(TASK::ET__TASK__ControlIncomingMessage(TASK::ET__TASK__ControlIncomingMessage::EV__TASK__START), device1);
current_location.update_lineno(126);
/* FRAMEWORK_Test.ttcn, line 126 */
MTC_component_p__task.send(TASK::ET__TASK__ControlIncomingMessage(TASK::ET__TASK__ControlIncomingMessage::EV__TASK__START), device2);
current_location.update_lineno(128);
/* FRAMEWORK_Test.ttcn, line 128 */
TIMER t("t");
current_location.update_lineno(128);
/* FRAMEWORK_Test.ttcn, line 128 */
t.start(3.0);
current_location.update_lineno(128);
/* FRAMEWORK_Test.ttcn, line 128 */
{
tmp_18:
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = t.timeout(NULL);
if (alt_flag == ALT_YES) break;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_18;
}
current_location.update_lineno(128);
/* FRAMEWORK_Test.ttcn, line 128 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone timeout statement failed in file FRAMEWORK_Test.ttcn, line 128.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(129);
/* FRAMEWORK_Test.ttcn, line 129 */
{
LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__ActionSequence tmp_19;
tmp_19.set_size(4);
{
LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__InterfaceAction& tmp_20 = tmp_19[0].InterfaceAction();
tmp_20.InterfaceName() = cs_1;
tmp_20.Command() = cs_2;
{
LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__InterfaceAction_Parameters& tmp_21 = tmp_20.Parameters();
tmp_21.set_size(1);
tmp_21[0] = cs_3;
}
tmp_20.Delay() = 0.0;
tmp_20.Timeout() = 1.0e1;
}
{
LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__InterfaceAction& tmp_22 = tmp_19[1].InterfaceAction();
tmp_22.InterfaceName() = cs_1;
tmp_22.Command() = cs_2;
{
LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__InterfaceAction_Parameters& tmp_23 = tmp_22.Parameters();
tmp_23.set_size(1);
tmp_23[0] = cs_4;
}
tmp_22.Delay() = 0.0;
tmp_22.Timeout() = 1.0e1;
}
{
LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__InterfaceAction& tmp_24 = tmp_19[2].InterfaceAction();
tmp_24.InterfaceName() = cs_1;
tmp_24.Command() = cs_2;
{
LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__InterfaceAction_Parameters& tmp_25 = tmp_24.Parameters();
tmp_25.set_size(1);
tmp_25[0] = cs_3;
}
tmp_24.Delay() = 0.0;
tmp_24.Timeout() = 1.0e1;
}
{
LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__InterfaceAction& tmp_26 = tmp_19[3].InterfaceAction();
tmp_26.InterfaceName() = cs_1;
tmp_26.Command() = cs_2;
{
LANGUAGE__DYNAMIC::LANGUAGE__DYNAMIC__InterfaceAction_Parameters& tmp_27 = tmp_26.Parameters();
tmp_27.set_size(1);
tmp_27[0] = cs_4;
}
tmp_26.Delay() = 0.0;
tmp_26.Timeout() = 1.0e1;
}
SEQUENCE__EXECUTOR::start_f__SEQUENCE__EXECUTOR__SequenceExecutor(executor, builder, tmp_19);
}
current_location.update_lineno(152);
/* FRAMEWORK_Test.ttcn, line 152 */
{
tmp_28:
alt_status alt_flag = ALT_UNCHECKED, default_flag = ALT_UNCHECKED;
TTCN_Snapshot::take_new(FALSE);
for ( ; ; ) {
if (alt_flag != ALT_NO) {
alt_flag = executor.done(NULL);
if (alt_flag == ALT_YES) break;
else if (alt_flag == ALT_REPEAT) goto tmp_28;
}
if (default_flag != ALT_NO) {
default_flag = TTCN_Default::try_altsteps();
if (default_flag == ALT_YES || default_flag == ALT_BREAK) break;
else if (default_flag == ALT_REPEAT) goto tmp_28;
}
current_location.update_lineno(152);
/* FRAMEWORK_Test.ttcn, line 152 */
if (alt_flag == ALT_NO && default_flag == ALT_NO) TTCN_error("Stand-alone done statement failed in file FRAMEWORK_Test.ttcn, line 152.");
TTCN_Snapshot::take_new(TRUE);
}
}
current_location.update_lineno(153);
/* FRAMEWORK_Test.ttcn, line 153 */
MTC_component_p__task.send(TASK::ET__TASK__ControlIncomingMessage(TASK::ET__TASK__ControlIncomingMessage::EV__TASK__STOP), device1);
current_location.update_lineno(154);
/* FRAMEWORK_Test.ttcn, line 154 */
MTC_component_p__task.send(TASK::ET__TASK__ControlIncomingMessage(TASK::ET__TASK__ControlIncomingMessage::EV__TASK__STOP), device2);
} catch (const TC_Error& tc_error) {
} catch (const TC_End& tc_end) {
TTCN_Logger::log_str(TTCN_FUNCTION, "Test case test was stopped.");
}
return TTCN_Runtime::end_testcase();
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("FRAMEWORK_Test.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "FRAMEWORK_Test");
SEQUENCE__EXECUTOR::module_object.pre_init_module();
module_object.add_function("f_GPIO_OutProxy", (genericfunc_t)&f__GPIO__OutProxy, (genericfunc_t)&start_f__GPIO__OutProxy);
module_object.add_function("f_GPIO_InProxy", (genericfunc_t)&f__GPIO__InProxy, (genericfunc_t)&start_f__GPIO__InProxy);
module_object.add_function("f_GPIO_Proxy", (genericfunc_t)&f__GPIO__Proxy, (genericfunc_t)&start_f__GPIO__Proxy);
module_object.add_testcase_nonpard("test", testcase_test);
}

static void post_init_module()
{
TTCN_Location current_location("FRAMEWORK_Test.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "FRAMEWORK_Test");
SEQUENCE__EXECUTOR::module_object.post_init_module();
}

static boolean init_comp_type(const char *component_type, boolean init_base_comps)
{
(void)init_base_comps;
if (!strcmp(component_type, "CT_GPIO_Proxy")) {
if (init_base_comps) {
Module_List::initialize_component("GPIO_Definitions", "CT_GPIO_Device", FALSE);
Module_List::initialize_component("GPIOPinPort", "GPIO_Base", FALSE);
Module_List::initialize_component("TASK", "CT_TASK_Task", FALSE);
Module_List::initialize_component("TEST_Definitions", "CT_TEST_Subject", FALSE);
}
return TRUE;
} else if (!strcmp(component_type, "MTC")) {
if (init_base_comps) {
Module_List::initialize_component("TEST_Definitions", "CT_TEST_Subject", FALSE);
Module_List::initialize_component("INTERFACE_STORE", "CT_INTERFACE_STORE_InterfaceStoreClient", FALSE);
}
MTC_component_p__task.activate_port();
return TRUE;
} else return FALSE;
}

static boolean start_ptc_function(const char *function_name, Text_Buf& function_arguments)
{
if (!strcmp(function_name, "f_GPIO_OutProxy")) {
INTEGER index;
index.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_GPIO_OutProxy(");
index.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__GPIO__OutProxy(index);
TTCN_Runtime::function_finished("f_GPIO_OutProxy");
return TRUE;
} else if (!strcmp(function_name, "f_GPIO_InProxy")) {
INTEGER index;
index.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_GPIO_InProxy(");
index.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__GPIO__InProxy(index);
TTCN_Runtime::function_finished("f_GPIO_InProxy");
return TRUE;
} else if (!strcmp(function_name, "f_GPIO_Proxy")) {
INTEGER index;
index.decode_text(function_arguments);
TTCN_Logger::begin_event(TTCN_Logger::PARALLEL_PTC);
TTCN_Logger::log_event_str("Starting function f_GPIO_Proxy(");
index.log();
TTCN_Logger::log_event_str(").");
TTCN_Logger::end_event();
TTCN_Runtime::function_started(function_arguments);
f__GPIO__Proxy(index);
TTCN_Runtime::function_finished("f_GPIO_Proxy");
return TRUE;
} else return FALSE;
}

static void module_control_part()
{
TTCN_Location current_location("FRAMEWORK_Test.ttcn", 157, TTCN_Location::LOCATION_CONTROLPART, "FRAMEWORK_Test");
TTCN_Runtime::begin_controlpart("FRAMEWORK_Test");
current_location.update_lineno(158);
/* FRAMEWORK_Test.ttcn, line 158 */
testcase_test(FALSE, 0.0);
TTCN_Runtime::end_controlpart();
}


} /* end of namespace */
