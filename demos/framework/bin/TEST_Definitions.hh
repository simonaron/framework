// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R3A
// for  (pi@pi-02) on Sat Apr 21 19:03:51 2018

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef TEST__Definitions_HH
#define TEST__Definitions_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 60300
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef TEST__Definitions_HH
#endif

namespace TEST__Definitions {

/* Forward declarations of classes */

class RT__TEST__Verdict;
class RT__TEST__Verdict_template;
class PT__TEST__VerdictOut;
class PT__TEST__VerdictIn;
class CT__TEST__SubjectMode;
class CT__TEST__SubjectMode_template;

} /* end of namespace */

#ifndef TEST__Definitions_HH
#define TEST__Definitions_HH

namespace TEST__Definitions {

/* Type definitions */

typedef COMPONENT CT__TEST__Subject;
typedef COMPONENT_template CT__TEST__Subject_template;
typedef COMPONENT CT__TEST__Watcher;
typedef COMPONENT_template CT__TEST__Watcher_template;

/* Class definitions */

class RT__TEST__Verdict {
  VERDICTTYPE field_verdict;
  CHARSTRING field_reason;
public:
  RT__TEST__Verdict();
  RT__TEST__Verdict(const VERDICTTYPE& par_verdict,
    const CHARSTRING& par_reason);
  RT__TEST__Verdict(const RT__TEST__Verdict& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RT__TEST__Verdict& operator=(const RT__TEST__Verdict& other_value);
  boolean operator==(const RT__TEST__Verdict& other_value) const;
  inline boolean operator!=(const RT__TEST__Verdict& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline VERDICTTYPE& verdict()
    {return field_verdict;}
  inline const VERDICTTYPE& verdict() const
    {return field_verdict;}
  inline CHARSTRING& reason()
    {return field_reason;}
  inline const CHARSTRING& reason() const
    {return field_reason;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class RT__TEST__Verdict_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RT__TEST__Verdict_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RT__TEST__Verdict& other_value);
void copy_template(const RT__TEST__Verdict_template& other_value);

public:
RT__TEST__Verdict_template();
RT__TEST__Verdict_template(template_sel other_value);
RT__TEST__Verdict_template(const RT__TEST__Verdict& other_value);
RT__TEST__Verdict_template(const OPTIONAL<RT__TEST__Verdict>& other_value);
RT__TEST__Verdict_template(const RT__TEST__Verdict_template& other_value);
~RT__TEST__Verdict_template();
RT__TEST__Verdict_template& operator=(template_sel other_value);
RT__TEST__Verdict_template& operator=(const RT__TEST__Verdict& other_value);
RT__TEST__Verdict_template& operator=(const OPTIONAL<RT__TEST__Verdict>& other_value);
RT__TEST__Verdict_template& operator=(const RT__TEST__Verdict_template& other_value);
boolean match(const RT__TEST__Verdict& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RT__TEST__Verdict valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RT__TEST__Verdict_template& list_item(unsigned int list_index) const;
VERDICTTYPE_template& verdict();
const VERDICTTYPE_template& verdict() const;
CHARSTRING_template& reason();
const CHARSTRING_template& reason() const;
int size_of() const;
void log() const;
void log_match(const RT__TEST__Verdict& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class PT__TEST__VerdictOut : public PORT {
public:
PT__TEST__VerdictOut(const char *par_port_name = NULL);
void send(const RT__TEST__Verdict& send_par, const COMPONENT& destination_component);
void send(const RT__TEST__Verdict& send_par);
void send(const RT__TEST__Verdict_template& send_par, const COMPONENT& destination_component);
void send(const RT__TEST__Verdict_template& send_par);
public:
private:
protected:
};

class PT__TEST__VerdictIn : public PORT {
enum msg_selection { MESSAGE_0 };
struct msg_queue_item : public msg_queue_item_base {
msg_selection item_selection;
union {
RT__TEST__Verdict *message_0;
};
component sender_component;
};

void remove_msg_queue_head();
protected:
void clear_queue();
public:
PT__TEST__VerdictIn(const char *par_port_name = NULL);
~PT__TEST__VerdictIn();
public:
alt_status receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status check_receive(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status trigger(const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status receive(const RT__TEST__Verdict_template& value_template, RT__TEST__Verdict *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status check_receive(const RT__TEST__Verdict_template& value_template, RT__TEST__Verdict *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
alt_status trigger(const RT__TEST__Verdict_template& value_template, RT__TEST__Verdict *value_redirect, const COMPONENT_template& sender_template, COMPONENT *sender_ptr, Index_Redirect*);
private:
void incoming_message(const RT__TEST__Verdict& incoming_par, component sender_component);
protected:
boolean process_message(const char *message_type, Text_Buf& incoming_buf, component sender_component, OCTETSTRING& slider);
};

class CT__TEST__SubjectMode : public Base_Type { // enum
friend class CT__TEST__SubjectMode_template;
public:
enum enum_type { TEST = 0, LIVE = 1, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
CT__TEST__SubjectMode();
CT__TEST__SubjectMode(int other_value);
CT__TEST__SubjectMode(enum_type other_value);
CT__TEST__SubjectMode(const CT__TEST__SubjectMode& other_value);

CT__TEST__SubjectMode& operator=(int other_value);
CT__TEST__SubjectMode& operator=(enum_type other_value);
CT__TEST__SubjectMode& operator=(const CT__TEST__SubjectMode& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const CT__TEST__SubjectMode& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const CT__TEST__SubjectMode& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const CT__TEST__SubjectMode& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const CT__TEST__SubjectMode& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const CT__TEST__SubjectMode& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const CT__TEST__SubjectMode& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const CT__TEST__SubjectMode& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class CT__TEST__SubjectMode_template : public Base_Template {
union {
CT__TEST__SubjectMode::enum_type single_value;
struct {
unsigned int n_values;
CT__TEST__SubjectMode_template *list_value;
} value_list;
};

void copy_template(const CT__TEST__SubjectMode_template& other_value);

public:
CT__TEST__SubjectMode_template();
CT__TEST__SubjectMode_template(template_sel other_value);
CT__TEST__SubjectMode_template(int other_value);
CT__TEST__SubjectMode_template(CT__TEST__SubjectMode::enum_type other_value);
CT__TEST__SubjectMode_template(const CT__TEST__SubjectMode& other_value);
CT__TEST__SubjectMode_template(const OPTIONAL<CT__TEST__SubjectMode>& other_value);
CT__TEST__SubjectMode_template(const CT__TEST__SubjectMode_template& other_value);
~CT__TEST__SubjectMode_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
CT__TEST__SubjectMode_template& operator=(template_sel other_value);
CT__TEST__SubjectMode_template& operator=(int other_value);
CT__TEST__SubjectMode_template& operator=(CT__TEST__SubjectMode::enum_type other_value);
CT__TEST__SubjectMode_template& operator=(const CT__TEST__SubjectMode& other_value);
CT__TEST__SubjectMode_template& operator=(const OPTIONAL<CT__TEST__SubjectMode>& other_value);
CT__TEST__SubjectMode_template& operator=(const CT__TEST__SubjectMode_template& other_value);

boolean match(CT__TEST__SubjectMode::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const CT__TEST__SubjectMode& other_value, boolean legacy = FALSE) const;
CT__TEST__SubjectMode::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CT__TEST__SubjectMode_template& list_item(unsigned int list_index);
void log() const;
void log_match(const CT__TEST__SubjectMode& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};


/* Global variable declarations */

extern const XERdescriptor_t RT__TEST__Verdict_verdict_xer_;
extern const TTCN_JSONdescriptor_t RT__TEST__Verdict_verdict_json_;
extern const TTCN_Typedescriptor_t RT__TEST__Verdict_verdict_descr_;
extern const XERdescriptor_t RT__TEST__Verdict_reason_xer_;
extern const TTCN_JSONdescriptor_t RT__TEST__Verdict_reason_json_;
extern const TTCN_Typedescriptor_t RT__TEST__Verdict_reason_descr_;
extern const TTCN_Typedescriptor_t RT__TEST__Verdict_descr_;
extern const TTCN_Typedescriptor_t CT__TEST__SubjectMode_descr_;
extern const TTCN_Typedescriptor_t& CT__TEST__Subject_descr_;
extern CT__TEST__SubjectMode CT__TEST__Subject_component_mode;
extern PT__TEST__VerdictOut CT__TEST__Subject_component_watcher;
extern const TTCN_Typedescriptor_t& CT__TEST__Watcher_descr_;
extern TIMER CT__TEST__Watcher_component_watchTimeout;
extern PT__TEST__VerdictIn CT__TEST__Watcher_component_subject;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
